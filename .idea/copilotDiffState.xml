<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/androidTest/java/com/devs/i210396_i211384/PostCreationWorkflowTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/androidTest/java/com/devs/i210396_i211384/PostCreationWorkflowTest.kt" />
              <option name="originalContent" value="package com.devs.i210396_i211384&#10;&#10;import android.Manifest&#10;import androidx.test.espresso.Espresso.onView&#10;import androidx.test.espresso.action.ViewActions.*&#10;import androidx.test.espresso.assertion.ViewAssertions.matches&#10;import androidx.test.espresso.matcher.ViewMatchers.*&#10;import androidx.test.ext.junit.rules.ActivityScenarioRule&#10;import androidx.test.ext.junit.runners.AndroidJUnit4&#10;import androidx.test.filters.LargeTest&#10;import androidx.test.rule.GrantPermissionRule&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.database.FirebaseDatabase&#10;import org.junit.After&#10;import org.junit.Before&#10;import org.junit.Rule&#10;import org.junit.Test&#10;import org.junit.runner.RunWith&#10;&#10;/**&#10; * Espresso Test for Post Creation Workflow&#10; *&#10; * This test validates the critical post upload workflow including:&#10; * - Navigation to Add Post screen&#10; * - Image selection UI elements&#10; * - Caption input functionality&#10; * - Post submission&#10; * - Permission handling&#10; * - UI state management during post creation&#10; */&#10;@RunWith(AndroidJUnit4::class)&#10;@LargeTest&#10;class PostCreationWorkflowTest {&#10;&#10;    @get:Rule&#10;    val activityRule = ActivityScenarioRule(AddPostScreen::class.java)&#10;&#10;    @get:Rule&#10;    val permissionRule: GrantPermissionRule = GrantPermissionRule.grant(&#10;        Manifest.permission.CAMERA,&#10;        Manifest.permission.READ_MEDIA_IMAGES&#10;    )&#10;&#10;    private lateinit var auth: FirebaseAuth&#10;    private lateinit var database: FirebaseDatabase&#10;&#10;    @Before&#10;    fun setUp() {&#10;        // Initialize Firebase services&#10;        auth = FirebaseAuth.getInstance()&#10;        database = FirebaseDatabase.getInstance()&#10;&#10;        // Sign in a test user before each test (required for AddPostScreen)&#10;        // In a real scenario, you would sign in with actual test credentials&#10;        // For now, we just ensure Firebase is initialized&#10;        Thread.sleep(1500)&#10;    }&#10;&#10;    @After&#10;    fun tearDown() {&#10;        // Clean up any test data if needed&#10;    }&#10;&#10;    /**&#10;     * Test Case 1: Verify all Add Post UI elements are displayed&#10;     */&#10;    @Test&#10;    fun testAddPostScreenUIElementsDisplayed() {&#10;        // Verify back button is displayed&#10;        onView(withId(R.id.btnBack))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify post button is displayed&#10;        onView(withId(R.id.btnPost))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Post&quot;)))&#10;&#10;        // Verify image preview area is displayed&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify select image text is displayed initially&#10;        onView(withId(R.id.tvSelectImage))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Tap to select image&quot;)))&#10;&#10;        // Verify camera button is displayed&#10;        onView(withId(R.id.btnCamera))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Camera&quot;)))&#10;&#10;        // Verify gallery button is displayed&#10;        onView(withId(R.id.btnGallery))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Gallery&quot;)))&#10;&#10;        // Verify caption input is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withHint(&quot;Write a caption...&quot;)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 2: Verify back button navigation&#10;     */&#10;    @Test&#10;    fun testBackButtonNavigatesBack() {&#10;        // Click back button&#10;        onView(withId(R.id.btnBack))&#10;            .perform(click())&#10;&#10;        // Wait for navigation&#10;        Thread.sleep(1000)&#10;&#10;        // Activity should finish or navigate back&#10;        // Verification depends on activity lifecycle&#10;    }&#10;&#10;    /**&#10;     * Test Case 3: Verify caption input accepts text&#10;     */&#10;    @Test&#10;    fun testCaptionInputAcceptsText() {&#10;        val testCaption = &quot;This is a test post caption with #hashtags and @mentions&quot;&#10;&#10;        // Type caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(testCaption), closeSoftKeyboard())&#10;&#10;        // Wait briefly&#10;        Thread.sleep(500)&#10;&#10;        // Verify caption field is still displayed with text&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(testCaption)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 4: Verify caption can be cleared and re-entered&#10;     */&#10;    @Test&#10;    fun testCaptionCanBeClearedAndReentered() {&#10;        // Type initial caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(&quot;First caption&quot;), closeSoftKeyboard())&#10;&#10;        // Clear and type new caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(clearText(), typeText(&quot;Second caption&quot;), closeSoftKeyboard())&#10;&#10;        // Verify new caption is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(&quot;Second caption&quot;)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 5: Verify long caption input&#10;     */&#10;    @Test&#10;    fun testLongCaptionInput() {&#10;        val longCaption = &quot;This is a very long caption that contains multiple sentences. &quot; +&#10;                &quot;It tests the multiline capability of the EditText field. &quot; +&#10;                &quot;Instagram allows captions up to 2,200 characters, so we should support long text. &quot; +&#10;                &quot;This includes emojis , hashtags #test #longcaption, and mentions @user123.&quot;&#10;&#10;        // Type long caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(longCaption), closeSoftKeyboard())&#10;&#10;        // Wait briefly&#10;        Thread.sleep(500)&#10;&#10;        // Verify caption field accepts and displays long text&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 6: Verify camera button interaction&#10;     */&#10;    @Test&#10;    fun testCameraButtonClickable() {&#10;        // Scroll to camera button if needed&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;&#10;        // Click camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(click())&#10;&#10;        // Wait for camera intent or permission dialog&#10;        Thread.sleep(2000)&#10;&#10;        // Note: Camera intent will be launched, but in test environment&#10;        // it may not complete. This verifies the button is clickable.&#10;    }&#10;&#10;    /**&#10;     * Test Case 7: Verify gallery button interaction&#10;     */&#10;    @Test&#10;    fun testGalleryButtonClickable() {&#10;        // Scroll to gallery button if needed&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;&#10;        // Click gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(click())&#10;&#10;        // Wait for gallery intent&#10;        Thread.sleep(2000)&#10;&#10;        // Note: Gallery intent will be launched, but in test environment&#10;        // it may not complete. This verifies the button is clickable.&#10;    }&#10;&#10;    /**&#10;     * Test Case 8: Verify post button without image selection&#10;     */&#10;    @Test&#10;    fun testPostButtonWithoutImageShowsError() {&#10;        // Type caption only without selecting image&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(&quot;Caption without image&quot;), closeSoftKeyboard())&#10;&#10;        // Click post button&#10;        onView(withId(R.id.btnPost))&#10;            .perform(click())&#10;&#10;        // Wait for validation&#10;        Thread.sleep(1500)&#10;&#10;        // Verify user remains on add post screen (validation should prevent posting)&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify select image text is still visible (no image selected)&#10;        onView(withId(R.id.tvSelectImage))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 9: Verify post button without caption (should still work)&#10;     */&#10;    @Test&#10;    fun testPostButtonWithoutCaption() {&#10;        // Don't type any caption&#10;        // Note: In a real test, you'd mock image selection&#10;&#10;        // Click post button&#10;        onView(withId(R.id.btnPost))&#10;            .perform(click())&#10;&#10;        // Wait for validation&#10;        Thread.sleep(1500)&#10;&#10;        // Verify screen is still displayed&#10;        // (Should show error or allow posting without caption depending on implementation)&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 10: Verify UI elements are properly scrollable&#10;     */&#10;    @Test&#10;    fun testScreenIsScrollable() {&#10;        // Verify image preview is visible at top&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll down to caption field&#10;        onView(withId(R.id.etCaption))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll to camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll to gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 11: Verify caption with special characters&#10;     */&#10;    @Test&#10;    fun testCaptionWithSpecialCharacters() {&#10;        val specialCaption = &quot;Testing special chars: !@#$%^&amp;*()_+-=[]{}|;':\&quot;,./&lt;&gt;?&quot;&#10;&#10;        // Type caption with special characters&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(specialCaption), closeSoftKeyboard())&#10;&#10;        // Verify caption is accepted&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 12: Verify caption with numbers&#10;     */&#10;    @Test&#10;    fun testCaptionWithNumbers() {&#10;        val numericCaption = &quot;Post 123 - Testing numbers 456789&quot;&#10;&#10;        // Type caption with numbers&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(numericCaption), closeSoftKeyboard())&#10;&#10;        // Verify caption is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(numericCaption)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 13: Verify multiple clicks on camera button&#10;     */&#10;    @Test&#10;    fun testMultipleCameraButtonClicks() {&#10;        // Scroll to camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;&#10;        // Click camera button multiple times&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(click())&#10;&#10;        Thread.sleep(1000)&#10;&#10;        // Verify button is still displayed (no crash from multiple clicks)&#10;        onView(withId(R.id.btnCamera))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 14: Verify post button is visible and has correct styling&#10;     */&#10;    @Test&#10;    fun testPostButtonStyling() {&#10;        // Verify post button text and color&#10;        onView(withId(R.id.btnPost))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Post&quot;)))&#10;            .check(matches(isClickable()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 15: Test complete post creation workflow (simulated)&#10;     * Note: This simulates the flow without actual image selection&#10;     */&#10;    @Test&#10;    fun testCompletePostCreationWorkflow() {&#10;        // Step 1: Verify screen loaded&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Step 2: Add caption&#10;        val caption = &quot;Beautiful sunset  #nature #photography&quot;&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(caption), closeSoftKeyboard())&#10;&#10;        Thread.sleep(500)&#10;&#10;        // Step 3: Verify caption was entered&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(caption)))&#10;&#10;        // Step 4: Scroll to gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;&#10;        // Step 5: Click gallery button (would open image picker in real app)&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(click())&#10;&#10;        Thread.sleep(1000)&#10;&#10;        // Note: In a real test with mocked image selection,&#10;        // you would verify the image preview updates and then click post&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.devs.i210396_i211384&#10;&#10;import android.Manifest&#10;import androidx.test.espresso.Espresso.onView&#10;import androidx.test.espresso.action.ViewActions.*&#10;import androidx.test.espresso.assertion.ViewAssertions.matches&#10;import androidx.test.espresso.matcher.ViewMatchers.*&#10;import androidx.test.ext.junit.rules.ActivityScenarioRule&#10;import androidx.test.ext.junit.runners.AndroidJUnit4&#10;import androidx.test.filters.LargeTest&#10;import androidx.test.rule.GrantPermissionRule&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.database.FirebaseDatabase&#10;import org.junit.After&#10;import org.junit.Before&#10;import org.junit.Rule&#10;import org.junit.Test&#10;import org.junit.runner.RunWith&#10;&#10;/**&#10; * Espresso Test for Post Creation Workflow&#10; *&#10; * This test validates the critical post upload workflow including:&#10; * - Navigation to Add Post screen&#10; * - Image selection UI elements&#10; * - Caption input functionality&#10; * - Post submission&#10; * - Permission handling&#10; * - UI state management during post creation&#10; */&#10;@RunWith(AndroidJUnit4::class)&#10;@LargeTest&#10;class PostCreationWorkflowTest {&#10;&#10;    @get:Rule&#10;    val activityRule = ActivityScenarioRule(AddPostScreen::class.java)&#10;&#10;    @get:Rule&#10;    val permissionRule: GrantPermissionRule = GrantPermissionRule.grant(&#10;        Manifest.permission.CAMERA,&#10;        Manifest.permission.READ_MEDIA_IMAGES&#10;    )&#10;&#10;    private lateinit var auth: FirebaseAuth&#10;    private lateinit var database: FirebaseDatabase&#10;&#10;    @Before&#10;    fun setUp() {&#10;        // Initialize Firebase services&#10;        auth = FirebaseAuth.getInstance()&#10;        database = FirebaseDatabase.getInstance()&#10;&#10;        // Sign in a test user before each test (required for AddPostScreen)&#10;        // In a real scenario, you would sign in with actual test credentials&#10;        // For now, we just ensure Firebase is initialized&#10;        Thread.sleep(1500)&#10;    }&#10;&#10;    @After&#10;    fun tearDown() {&#10;        // Clean up any test data if needed&#10;    }&#10;&#10;    /**&#10;     * Test Case 1: Verify all Add Post UI elements are displayed&#10;     */&#10;    @Test&#10;    fun testAddPostScreenUIElementsDisplayed() {&#10;        // Verify back button is displayed&#10;        onView(withId(R.id.btnBack))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify post button is displayed&#10;        onView(withId(R.id.btnPost))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Post&quot;)))&#10;&#10;        // Verify image preview area is displayed&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify select image text is displayed initially&#10;        onView(withId(R.id.tvSelectImage))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Tap to select image&quot;)))&#10;&#10;        // Verify camera button is displayed&#10;        onView(withId(R.id.btnCamera))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Camera&quot;)))&#10;&#10;        // Verify gallery button is displayed&#10;        onView(withId(R.id.btnGallery))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Gallery&quot;)))&#10;&#10;        // Verify caption input is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withHint(&quot;Write a caption...&quot;)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 2: Verify back button navigation&#10;     */&#10;    @Test&#10;    fun testBackButtonNavigatesBack() {&#10;        // Click back button&#10;        onView(withId(R.id.btnBack))&#10;            .perform(click())&#10;&#10;        // Wait for navigation&#10;        Thread.sleep(1000)&#10;&#10;        // Activity should finish or navigate back&#10;        // Verification depends on activity lifecycle&#10;    }&#10;&#10;    /**&#10;     * Test Case 3: Verify caption input accepts text&#10;     */&#10;    @Test&#10;    fun testCaptionInputAcceptsText() {&#10;        val testCaption = &quot;This is a test post caption with #hashtags and @mentions&quot;&#10;&#10;        // Type caption using replaceText instead of typeText&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(testCaption), closeSoftKeyboard())&#10;&#10;        // Wait briefly&#10;        Thread.sleep(500)&#10;&#10;        // Verify caption field is still displayed with text&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(testCaption)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 4: Verify caption can be cleared and re-entered&#10;     */&#10;    @Test&#10;    fun testCaptionCanBeClearedAndReentered() {&#10;        // Type initial caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(&quot;First caption&quot;), closeSoftKeyboard())&#10;&#10;        // Clear and type new caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(clearText(), replaceText(&quot;Second caption&quot;), closeSoftKeyboard())&#10;&#10;        // Verify new caption is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(&quot;Second caption&quot;)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 5: Verify long caption input&#10;     */&#10;    @Test&#10;    fun testLongCaptionInput() {&#10;        val longCaption = &quot;This is a very long caption that contains multiple sentences. &quot; +&#10;                &quot;It tests the multiline capability of the EditText field. &quot; +&#10;                &quot;Instagram allows captions up to 2,200 characters, so we should support long text. &quot; +&#10;                &quot;This includes emojis, hashtags #test #longcaption, and mentions @user123.&quot;&#10;&#10;        // Type long caption using replaceText&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(longCaption), closeSoftKeyboard())&#10;&#10;        // Wait briefly&#10;        Thread.sleep(500)&#10;&#10;        // Verify caption field accepts and displays long text&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 6: Verify camera button interaction&#10;     */&#10;    @Test&#10;    fun testCameraButtonClickable() {&#10;        // Scroll to camera button if needed&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;&#10;        // Click camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(click())&#10;&#10;        // Wait for camera intent or permission dialog&#10;        Thread.sleep(2000)&#10;&#10;        // Note: Camera intent will be launched, but in test environment&#10;        // it may not complete. This verifies the button is clickable.&#10;    }&#10;&#10;    /**&#10;     * Test Case 7: Verify gallery button interaction&#10;     */&#10;    @Test&#10;    fun testGalleryButtonClickable() {&#10;        // Scroll to gallery button if needed&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;&#10;        // Click gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(click())&#10;&#10;        // Wait for gallery intent&#10;        Thread.sleep(2000)&#10;&#10;        // Note: Gallery intent will be launched, but in test environment&#10;        // it may not complete. This verifies the button is clickable.&#10;    }&#10;&#10;    /**&#10;     * Test Case 8: Verify post button without image selection&#10;     */&#10;    @Test&#10;    fun testPostButtonWithoutImageShowsError() {&#10;        // Type caption only without selecting image&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(&quot;Caption without image&quot;), closeSoftKeyboard())&#10;&#10;        // Click post button&#10;        onView(withId(R.id.btnPost))&#10;            .perform(click())&#10;&#10;        // Wait for validation&#10;        Thread.sleep(1500)&#10;&#10;        // Verify user remains on add post screen (validation should prevent posting)&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify select image text is still visible (no image selected)&#10;        onView(withId(R.id.tvSelectImage))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 9: Verify post button without caption (should still work)&#10;     */&#10;    @Test&#10;    fun testPostButtonWithoutCaption() {&#10;        // Don't type any caption&#10;        // Note: In a real test, you'd mock image selection&#10;&#10;        // Click post button&#10;        onView(withId(R.id.btnPost))&#10;            .perform(click())&#10;&#10;        // Wait for validation&#10;        Thread.sleep(1500)&#10;&#10;        // Verify screen is still displayed&#10;        // (Should show error or allow posting without caption depending on implementation)&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 10: Verify UI elements are properly scrollable&#10;     */&#10;    @Test&#10;    fun testScreenIsScrollable() {&#10;        // Verify image preview is visible at top&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll down to caption field&#10;        onView(withId(R.id.etCaption))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll to camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll to gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 11: Verify caption with special characters&#10;     */&#10;    @Test&#10;    fun testCaptionWithSpecialCharacters() {&#10;        val specialCaption = &quot;Testing special chars: !@#$%^&amp;*()_+-=[]{}|;':\&quot;,./&lt;&gt;?&quot;&#10;&#10;        // Type caption with special characters using replaceText&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(specialCaption), closeSoftKeyboard())&#10;&#10;        // Verify caption is accepted&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 12: Verify caption with numbers&#10;     */&#10;    @Test&#10;    fun testCaptionWithNumbers() {&#10;        val numericCaption = &quot;Post 123 - Testing numbers 456789&quot;&#10;&#10;        // Type caption with numbers using replaceText&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(numericCaption), closeSoftKeyboard())&#10;&#10;        // Verify caption is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(numericCaption)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 13: Verify multiple clicks on camera button&#10;     */&#10;    @Test&#10;    fun testMultipleCameraButtonClicks() {&#10;        // Scroll to camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;&#10;        // Verify camera button is displayed before clicking&#10;        onView(withId(R.id.btnCamera))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Click camera button (this will launch camera intent)&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(click())&#10;&#10;        // Wait for camera intent to launch&#10;        Thread.sleep(1000)&#10;&#10;        // Note: After clicking camera button, camera intent is launched&#10;        // and the activity goes to background. We cannot verify UI elements&#10;        // after the camera intent is launched in a test environment.&#10;        // This test successfully verifies the button is clickable and doesn't crash.&#10;    }&#10;&#10;    /**&#10;     * Test Case 14: Verify post button is visible and has correct styling&#10;     */&#10;    @Test&#10;    fun testPostButtonStyling() {&#10;        // Verify post button text and color&#10;        onView(withId(R.id.btnPost))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Post&quot;)))&#10;            .check(matches(isClickable()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 15: Test complete post creation workflow (simulated)&#10;     * Note: This simulates the flow without actual image selection&#10;     */&#10;    @Test&#10;    fun testCompletePostCreationWorkflow() {&#10;        // Step 1: Verify screen loaded&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Step 2: Add caption (without emojis to avoid IME issues)&#10;        val caption = &quot;Beautiful sunset #nature #photography&quot;&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(caption), closeSoftKeyboard())&#10;&#10;        Thread.sleep(500)&#10;&#10;        // Step 3: Verify caption was entered&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(caption)))&#10;&#10;        // Step 4: Scroll to gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;&#10;        // Step 5: Click gallery button (would open image picker in real app)&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(click())&#10;&#10;        Thread.sleep(1000)&#10;&#10;        // Note: In a real test with mocked image selection,&#10;        // you would verify the image preview updates and then click post&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/callScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/callScreen.kt" />
              <option name="originalContent" value="package com.hamzatariq.i210396&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.SurfaceView&#10;import android.view.View&#10;import android.widget.FrameLayout&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.hamzatariq.i210396.services.CallService&#10;import com.hamzatariq.i210396.utils.AgoraConfig&#10;import com.hamzatariq.i210396.utils.AgoraTokenGenerator&#10;import com.hamzatariq.i210396.utils.ImageUtils&#10;import io.agora.rtc2.ChannelMediaOptions&#10;import io.agora.rtc2.Constants&#10;import io.agora.rtc2.IRtcEngineEventHandler&#10;import io.agora.rtc2.RtcEngine&#10;import io.agora.rtc2.RtcEngineConfig&#10;import io.agora.rtc2.video.VideoCanvas&#10;&#10;class callScreen : AppCompatActivity() {&#10;    private var mRtcEngine: RtcEngine? = null&#10;    private lateinit var localVideoContainer: FrameLayout&#10;    private lateinit var remoteVideoContainer: FrameLayout&#10;    private lateinit var profileImage: ImageView&#10;    private lateinit var nameText: TextView&#10;    private lateinit var durationText: TextView&#10;    private lateinit var callStatusText: TextView&#10;&#10;    private var callId: String = &quot;&quot;&#10;    private var channelName: String = &quot;&quot;&#10;    private var callType: String = &quot;video&quot;&#10;    private var isIncoming: Boolean = false&#10;    private var otherUserId: String = &quot;&quot;&#10;    private var otherUserName: String = &quot;&quot;&#10;    private var otherUserImage: String = &quot;&quot;&#10;&#10;    private var isMuted = false&#10;    private var isSpeakerOn = true&#10;    private var isCameraOn = true&#10;    private var isFrontCamera = true&#10;&#10;    private var callStartTime: Long = 0&#10;    private var durationHandler: Handler? = null&#10;    private var durationRunnable: Runnable? = null&#10;&#10;    private val PERMISSION_REQ_ID = 22&#10;    private val REQUESTED_PERMISSIONS = arrayOf(&#10;        Manifest.permission.RECORD_AUDIO,&#10;        Manifest.permission.CAMERA&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_call)&#10;&#10;        // Get call data&#10;        callId = intent.getStringExtra(&quot;callId&quot;) ?: &quot;&quot;&#10;        channelName = intent.getStringExtra(&quot;channelName&quot;) ?: &quot;&quot;&#10;        callType = intent.getStringExtra(&quot;callType&quot;) ?: &quot;video&quot;&#10;        isIncoming = intent.getBooleanExtra(&quot;isIncoming&quot;, false)&#10;        otherUserId = intent.getStringExtra(&quot;otherUserId&quot;) ?: &quot;&quot;&#10;        otherUserName = intent.getStringExtra(&quot;otherUserName&quot;) ?: &quot;User&quot;&#10;        otherUserImage = intent.getStringExtra(&quot;otherUserImage&quot;) ?: &quot;&quot;&#10;&#10;        initViews()&#10;&#10;        if (checkSelfPermission()) {&#10;            initializeAndJoinChannel()&#10;        }&#10;&#10;        setupCallStatusListener()&#10;    }&#10;&#10;    private fun initViews() {&#10;        localVideoContainer = findViewById(R.id.localVideoContainer)&#10;        remoteVideoContainer = findViewById(R.id.remoteVideoContainer)&#10;        profileImage = findViewById(R.id.ivProfile)&#10;        nameText = findViewById(R.id.tvName)&#10;        durationText = findViewById(R.id.tvDuration)&#10;        callStatusText = findViewById(R.id.tvCallStatus)&#10;&#10;        nameText.text = otherUserName&#10;        if (otherUserImage.isNotEmpty()) {&#10;            ImageUtils.loadBase64Image(profileImage, otherUserImage)&#10;        }&#10;&#10;        // Initially hide video containers for audio call&#10;        if (callType == &quot;audio&quot;) {&#10;            localVideoContainer.visibility = View.GONE&#10;            remoteVideoContainer.visibility = View.GONE&#10;            profileImage.visibility = View.VISIBLE&#10;        } else {&#10;            profileImage.visibility = View.GONE&#10;        }&#10;&#10;        callStatusText.text = if (isIncoming) &quot;Connecting...&quot; else &quot;Calling...&quot;&#10;        durationText.text = &quot;00:00&quot;&#10;&#10;        // Setup buttons&#10;        findViewById&lt;ImageView&gt;(R.id.ivEndCall).setOnClickListener {&#10;            endCall()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setOnClickListener {&#10;            toggleMute()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setOnClickListener {&#10;            toggleSpeaker()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSwitchCamera)?.setOnClickListener {&#10;            switchCamera()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setOnClickListener {&#10;            toggleVideo()&#10;        }&#10;    }&#10;&#10;    private fun checkSelfPermission(): Boolean {&#10;        val permissionsNeeded = REQUESTED_PERMISSIONS.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsNeeded.isNotEmpty()) {&#10;            ActivityCompat.requestPermissions(this, permissionsNeeded.toTypedArray(), PERMISSION_REQ_ID)&#10;            return false&#10;        }&#10;        return true&#10;    }&#10;&#10;    override fun onRequestPermissionsResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray&#10;    ) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == PERMISSION_REQ_ID) {&#10;            if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {&#10;                initializeAndJoinChannel()&#10;            } else {&#10;                Toast.makeText(this, &quot;Permissions required for call&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeAndJoinChannel() {&#10;        try {&#10;            // Validate APP_ID&#10;            if (AgoraConfig.APP_ID.isEmpty() || AgoraConfig.APP_ID.contains(&quot;YOUR_AGORA&quot;)) {&#10;                Toast.makeText(this, &quot;Invalid Agora App ID. Please check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            val config = RtcEngineConfig().apply {&#10;                mContext = applicationContext&#10;                mAppId = AgoraConfig.APP_ID&#10;                mEventHandler = rtcEventHandler&#10;            }&#10;&#10;            mRtcEngine = RtcEngine.create(config)&#10;&#10;            if (mRtcEngine == null) {&#10;                Toast.makeText(this, &quot;Failed to create RTC Engine&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            if (callType == &quot;video&quot;) {&#10;                mRtcEngine?.enableVideo()&#10;                setupLocalVideo()&#10;            } else {&#10;                mRtcEngine?.disableVideo()&#10;            }&#10;&#10;            mRtcEngine?.setDefaultAudioRoutetoSpeakerphone(true)&#10;&#10;            val options = ChannelMediaOptions().apply {&#10;                channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION&#10;                clientRoleType = Constants.CLIENT_ROLE_BROADCASTER&#10;            }&#10;&#10;            // Generate Agora token for authentication&#10;            val token = if (AgoraConfig.APP_CERTIFICATE.isNotEmpty()) {&#10;                // Generate token if certificate is available&#10;                AgoraTokenGenerator.generateToken(&#10;                    channelName = channelName,&#10;                    uid = 0, // Use 0 for auto-assigned UID&#10;                    role = 1, // 1 = publisher&#10;                    privilegeExpiredTs = 0 // Will use default 1 hour expiration&#10;                )&#10;            } else {&#10;                // Use null token for testing mode (must be enabled in Agora console)&#10;                null&#10;            }&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel: $channelName&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Token mode: ${if (token != null) &quot;Authenticated&quot; else &quot;Testing (null)&quot;}&quot;)&#10;            if (token != null) {&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token generated: ${if (token.isNotEmpty()) &quot;Yes (${token.length} chars)&quot; else &quot;Failed&quot;}&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token preview: ${token.take(50)}...&quot;)&#10;            }&#10;&#10;            if (token != null &amp;&amp; token.isEmpty()) {&#10;                Toast.makeText(this, &quot;Failed to generate token. Check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            // Join channel with generated token (or null for testing mode)&#10;            val result = mRtcEngine?.joinChannel(token, channelName, 0, options)&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;joinChannel result: $result&quot;)&#10;&#10;            if (result != 0) {&#10;                Toast.makeText(this, &quot;Failed to join channel. Error code: $result&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(this, &quot;Failed to initialize call: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun setupLocalVideo() {&#10;        val surfaceView = SurfaceView(this)&#10;        localVideoContainer.addView(surfaceView)&#10;        mRtcEngine?.setupLocalVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, 0))&#10;        mRtcEngine?.startPreview()&#10;    }&#10;&#10;    private fun setupRemoteVideo(uid: Int) {&#10;        runOnUiThread {&#10;            if (callType == &quot;video&quot;) {&#10;                profileImage.visibility = View.GONE&#10;                remoteVideoContainer.visibility = View.VISIBLE&#10;&#10;                val surfaceView = SurfaceView(this)&#10;                remoteVideoContainer.addView(surfaceView)&#10;                mRtcEngine?.setupRemoteVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, uid))&#10;            }&#10;&#10;            callStatusText.visibility = View.GONE&#10;            startCallDuration()&#10;        }&#10;    }&#10;&#10;    private val rtcEventHandler = object : IRtcEngineEventHandler() {&#10;        override fun onUserJoined(uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                setupRemoteVideo(uid)&#10;            }&#10;        }&#10;&#10;        override fun onUserOffline(uid: Int, reason: Int) {&#10;            runOnUiThread {&#10;                remoteVideoContainer.removeAllViews()&#10;                endCall()&#10;            }&#10;        }&#10;&#10;        override fun onJoinChannelSuccess(channel: String?, uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                callStatusText.text = &quot;Connected&quot;&#10;            }&#10;        }&#10;&#10;        override fun onError(err: Int) {&#10;            runOnUiThread {&#10;                Toast.makeText(this@callScreen, &quot;Call error: $err&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun toggleMute() {&#10;        isMuted = !isMuted&#10;        mRtcEngine?.muteLocalAudioStream(isMuted)&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setImageResource(&#10;            if (isMuted) R.drawable.ic_mic_off else R.drawable.ic_mic_on&#10;        )&#10;    }&#10;&#10;    private fun toggleSpeaker() {&#10;        isSpeakerOn = !isSpeakerOn&#10;        mRtcEngine?.setEnableSpeakerphone(isSpeakerOn)&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setImageResource(&#10;            if (isSpeakerOn) R.drawable.speaker else R.drawable.ic_speaker_off&#10;        )&#10;    }&#10;&#10;    private fun switchCamera() {&#10;        if (callType == &quot;video&quot;) {&#10;            mRtcEngine?.switchCamera()&#10;            isFrontCamera = !isFrontCamera&#10;        }&#10;    }&#10;&#10;    private fun toggleVideo() {&#10;        if (callType == &quot;video&quot;) {&#10;            isCameraOn = !isCameraOn&#10;            mRtcEngine?.muteLocalVideoStream(!isCameraOn)&#10;            localVideoContainer.visibility = if (isCameraOn) View.VISIBLE else View.GONE&#10;            findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setImageResource(&#10;                if (isCameraOn) R.drawable.ic_video_on else R.drawable.ic_video_off&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun startCallDuration() {&#10;        callStartTime = System.currentTimeMillis()&#10;        durationHandler = Handler(Looper.getMainLooper())&#10;        durationRunnable = object : Runnable {&#10;            override fun run() {&#10;                val elapsed = (System.currentTimeMillis() - callStartTime) / 1000&#10;                val minutes = elapsed / 60&#10;                val seconds = elapsed % 60&#10;                durationText.text = String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;                durationHandler?.postDelayed(this, 1000)&#10;            }&#10;        }&#10;        durationHandler?.post(durationRunnable!!)&#10;    }&#10;&#10;    private fun setupCallStatusListener() {&#10;        CallService.listenToCallStatus(callId) { status -&gt;&#10;            runOnUiThread {&#10;                when (status) {&#10;                    &quot;rejected&quot; -&gt; {&#10;                        Toast.makeText(this, &quot;Call rejected&quot;, Toast.LENGTH_SHORT).show()&#10;                        finish()&#10;                    }&#10;                    &quot;ended&quot; -&gt; {&#10;                        finish()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endCall() {&#10;        CallService.updateCallStatus(callId, &quot;ended&quot;)&#10;        CallService.endCall(callId)&#10;        leaveChannel()&#10;        finish()&#10;    }&#10;&#10;    private fun leaveChannel() {&#10;        mRtcEngine?.leaveChannel()&#10;        mRtcEngine?.stopPreview()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        durationHandler?.removeCallbacks(durationRunnable!!)&#10;        leaveChannel()&#10;        RtcEngine.destroy()&#10;        mRtcEngine = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.i210396&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.SurfaceView&#10;import android.view.View&#10;import android.widget.FrameLayout&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.hamzatariq.i210396.services.CallService&#10;import com.hamzatariq.i210396.utils.AgoraConfig&#10;import com.hamzatariq.i210396.utils.AgoraTokenGenerator&#10;import com.hamzatariq.i210396.utils.ImageUtils&#10;import io.agora.rtc2.ChannelMediaOptions&#10;import io.agora.rtc2.Constants&#10;import io.agora.rtc2.IRtcEngineEventHandler&#10;import io.agora.rtc2.RtcEngine&#10;import io.agora.rtc2.RtcEngineConfig&#10;import io.agora.rtc2.video.VideoCanvas&#10;&#10;class callScreen : AppCompatActivity() {&#10;    private var mRtcEngine: RtcEngine? = null&#10;    private lateinit var localVideoContainer: FrameLayout&#10;    private lateinit var remoteVideoContainer: FrameLayout&#10;    private lateinit var profileImage: ImageView&#10;    private lateinit var nameText: TextView&#10;    private lateinit var durationText: TextView&#10;    private lateinit var callStatusText: TextView&#10;&#10;    private var callId: String = &quot;&quot;&#10;    private var channelName: String = &quot;&quot;&#10;    private var callType: String = &quot;video&quot;&#10;    private var isIncoming: Boolean = false&#10;    private var otherUserId: String = &quot;&quot;&#10;    private var otherUserName: String = &quot;&quot;&#10;    private var otherUserImage: String = &quot;&quot;&#10;&#10;    private var isMuted = false&#10;    private var isSpeakerOn = true&#10;    private var isCameraOn = true&#10;    private var isFrontCamera = true&#10;&#10;    private var callStartTime: Long = 0&#10;    private var durationHandler: Handler? = null&#10;    private var durationRunnable: Runnable? = null&#10;&#10;    private val PERMISSION_REQ_ID = 22&#10;    private val REQUESTED_PERMISSIONS = arrayOf(&#10;        Manifest.permission.RECORD_AUDIO,&#10;        Manifest.permission.CAMERA&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_call)&#10;&#10;        // Get call data&#10;        callId = intent.getStringExtra(&quot;callId&quot;) ?: &quot;&quot;&#10;        channelName = intent.getStringExtra(&quot;channelName&quot;) ?: &quot;&quot;&#10;        callType = intent.getStringExtra(&quot;callType&quot;) ?: &quot;video&quot;&#10;        isIncoming = intent.getBooleanExtra(&quot;isIncoming&quot;, false)&#10;        otherUserId = intent.getStringExtra(&quot;otherUserId&quot;) ?: &quot;&quot;&#10;        otherUserName = intent.getStringExtra(&quot;otherUserName&quot;) ?: &quot;User&quot;&#10;        otherUserImage = intent.getStringExtra(&quot;otherUserImage&quot;) ?: &quot;&quot;&#10;&#10;        initViews()&#10;&#10;        if (checkSelfPermission()) {&#10;            initializeAndJoinChannel()&#10;        }&#10;&#10;        setupCallStatusListener()&#10;    }&#10;&#10;    private fun initViews() {&#10;        localVideoContainer = findViewById(R.id.localVideoContainer)&#10;        remoteVideoContainer = findViewById(R.id.remoteVideoContainer)&#10;        profileImage = findViewById(R.id.ivProfile)&#10;        nameText = findViewById(R.id.tvName)&#10;        durationText = findViewById(R.id.tvDuration)&#10;        callStatusText = findViewById(R.id.tvCallStatus)&#10;&#10;        nameText.text = otherUserName&#10;        if (otherUserImage.isNotEmpty()) {&#10;            ImageUtils.loadBase64Image(profileImage, otherUserImage)&#10;        }&#10;&#10;        // Initially hide video containers for audio call&#10;        if (callType == &quot;audio&quot;) {&#10;            localVideoContainer.visibility = View.GONE&#10;            remoteVideoContainer.visibility = View.GONE&#10;            profileImage.visibility = View.VISIBLE&#10;        } else {&#10;            profileImage.visibility = View.GONE&#10;        }&#10;&#10;        callStatusText.text = if (isIncoming) &quot;Connecting...&quot; else &quot;Calling...&quot;&#10;        durationText.text = &quot;00:00&quot;&#10;&#10;        // Setup buttons&#10;        findViewById&lt;ImageView&gt;(R.id.ivEndCall).setOnClickListener {&#10;            endCall()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setOnClickListener {&#10;            toggleMute()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setOnClickListener {&#10;            toggleSpeaker()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSwitchCamera)?.setOnClickListener {&#10;            switchCamera()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setOnClickListener {&#10;            toggleVideo()&#10;        }&#10;    }&#10;&#10;    private fun checkSelfPermission(): Boolean {&#10;        val permissionsNeeded = REQUESTED_PERMISSIONS.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsNeeded.isNotEmpty()) {&#10;            ActivityCompat.requestPermissions(this, permissionsNeeded.toTypedArray(), PERMISSION_REQ_ID)&#10;            return false&#10;        }&#10;        return true&#10;    }&#10;&#10;    override fun onRequestPermissionsResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray&#10;    ) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == PERMISSION_REQ_ID) {&#10;            if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {&#10;                initializeAndJoinChannel()&#10;            } else {&#10;                Toast.makeText(this, &quot;Permissions required for call&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeAndJoinChannel() {&#10;        try {&#10;            // Validate APP_ID&#10;            if (AgoraConfig.APP_ID.isEmpty() || AgoraConfig.APP_ID.contains(&quot;YOUR_AGORA&quot;)) {&#10;                Toast.makeText(this, &quot;Invalid Agora App ID. Please check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            val config = RtcEngineConfig().apply {&#10;                mContext = applicationContext&#10;                mAppId = AgoraConfig.APP_ID&#10;                mEventHandler = rtcEventHandler&#10;            }&#10;&#10;            mRtcEngine = RtcEngine.create(config)&#10;&#10;            if (mRtcEngine == null) {&#10;                Toast.makeText(this, &quot;Failed to create RTC Engine&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            if (callType == &quot;video&quot;) {&#10;                mRtcEngine?.enableVideo()&#10;                setupLocalVideo()&#10;            } else {&#10;                mRtcEngine?.disableVideo()&#10;            }&#10;&#10;            mRtcEngine?.setDefaultAudioRoutetoSpeakerphone(true)&#10;&#10;            val options = ChannelMediaOptions().apply {&#10;                channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION&#10;                clientRoleType = Constants.CLIENT_ROLE_BROADCASTER&#10;            }&#10;&#10;            // Generate Agora token for authentication&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;=== TOKEN GENERATION DEBUG ===&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;APP_ID: ${AgoraConfig.APP_ID}&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;APP_CERTIFICATE: ${AgoraConfig.APP_CERTIFICATE}&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel Name: $channelName&quot;)&#10;&#10;            val token = if (AgoraConfig.APP_CERTIFICATE.isNotEmpty()) {&#10;                // Generate token if certificate is available&#10;                val generatedToken = AgoraTokenGenerator.generateToken(&#10;                    channelName = channelName,&#10;                    uid = 0, // Use 0 for auto-assigned UID&#10;                    role = 1, // 1 = publisher&#10;                    privilegeExpiredTs = 0 // Will use default 1 hour expiration&#10;                )&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token generated: $generatedToken&quot;)&#10;                generatedToken&#10;            } else {&#10;                // Use null token for testing mode (must be enabled in Agora console)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Using null token (testing mode)&quot;)&#10;                null&#10;            }&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel: $channelName&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Token mode: ${if (token != null) &quot;Authenticated&quot; else &quot;Testing (null)&quot;}&quot;)&#10;            if (token != null) {&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token generated: ${if (token.isNotEmpty()) &quot;Yes (${token.length} chars)&quot; else &quot;Failed&quot;}&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token preview: ${token.take(50)}...&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token full: $token&quot;)&#10;            }&#10;&#10;            if (token != null &amp;&amp; token.isEmpty()) {&#10;                Toast.makeText(this, &quot;Failed to generate token. Check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            // Join channel with generated token (or null for testing mode)&#10;            val result = mRtcEngine?.joinChannel(token, channelName, 0, options)&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;joinChannel result: $result&quot;)&#10;&#10;            if (result != 0) {&#10;                Toast.makeText(this, &quot;Failed to join channel. Error code: $result&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(this, &quot;Failed to initialize call: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun setupLocalVideo() {&#10;        val surfaceView = SurfaceView(this)&#10;        localVideoContainer.addView(surfaceView)&#10;        mRtcEngine?.setupLocalVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, 0))&#10;        mRtcEngine?.startPreview()&#10;    }&#10;&#10;    private fun setupRemoteVideo(uid: Int) {&#10;        runOnUiThread {&#10;            if (callType == &quot;video&quot;) {&#10;                profileImage.visibility = View.GONE&#10;                remoteVideoContainer.visibility = View.VISIBLE&#10;&#10;                val surfaceView = SurfaceView(this)&#10;                remoteVideoContainer.addView(surfaceView)&#10;                mRtcEngine?.setupRemoteVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, uid))&#10;            }&#10;&#10;            callStatusText.visibility = View.GONE&#10;            startCallDuration()&#10;        }&#10;    }&#10;&#10;    private val rtcEventHandler = object : IRtcEngineEventHandler() {&#10;        override fun onUserJoined(uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                setupRemoteVideo(uid)&#10;            }&#10;        }&#10;&#10;        override fun onUserOffline(uid: Int, reason: Int) {&#10;            runOnUiThread {&#10;                remoteVideoContainer.removeAllViews()&#10;                endCall()&#10;            }&#10;        }&#10;&#10;        override fun onJoinChannelSuccess(channel: String?, uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                callStatusText.text = &quot;Connected&quot;&#10;            }&#10;        }&#10;&#10;        override fun onError(err: Int) {&#10;            runOnUiThread {&#10;                Toast.makeText(this@callScreen, &quot;Call error: $err&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun toggleMute() {&#10;        isMuted = !isMuted&#10;        mRtcEngine?.muteLocalAudioStream(isMuted)&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setImageResource(&#10;            if (isMuted) R.drawable.ic_mic_off else R.drawable.ic_mic_on&#10;        )&#10;    }&#10;&#10;    private fun toggleSpeaker() {&#10;        isSpeakerOn = !isSpeakerOn&#10;        mRtcEngine?.setEnableSpeakerphone(isSpeakerOn)&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setImageResource(&#10;            if (isSpeakerOn) R.drawable.speaker else R.drawable.ic_speaker_off&#10;        )&#10;    }&#10;&#10;    private fun switchCamera() {&#10;        if (callType == &quot;video&quot;) {&#10;            mRtcEngine?.switchCamera()&#10;            isFrontCamera = !isFrontCamera&#10;        }&#10;    }&#10;&#10;    private fun toggleVideo() {&#10;        if (callType == &quot;video&quot;) {&#10;            isCameraOn = !isCameraOn&#10;            mRtcEngine?.muteLocalVideoStream(!isCameraOn)&#10;            localVideoContainer.visibility = if (isCameraOn) View.VISIBLE else View.GONE&#10;            findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setImageResource(&#10;                if (isCameraOn) R.drawable.ic_video_on else R.drawable.ic_video_off&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun startCallDuration() {&#10;        callStartTime = System.currentTimeMillis()&#10;        durationHandler = Handler(Looper.getMainLooper())&#10;        durationRunnable = object : Runnable {&#10;            override fun run() {&#10;                val elapsed = (System.currentTimeMillis() - callStartTime) / 1000&#10;                val minutes = elapsed / 60&#10;                val seconds = elapsed % 60&#10;                durationText.text = String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;                durationHandler?.postDelayed(this, 1000)&#10;            }&#10;        }&#10;        durationHandler?.post(durationRunnable!!)&#10;    }&#10;&#10;    private fun setupCallStatusListener() {&#10;        CallService.listenToCallStatus(callId) { status -&gt;&#10;            runOnUiThread {&#10;                when (status) {&#10;                    &quot;rejected&quot; -&gt; {&#10;                        Toast.makeText(this, &quot;Call rejected&quot;, Toast.LENGTH_SHORT).show()&#10;                        finish()&#10;                    }&#10;                    &quot;ended&quot; -&gt; {&#10;                        finish()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endCall() {&#10;        CallService.updateCallStatus(callId, &quot;ended&quot;)&#10;        CallService.endCall(callId)&#10;        leaveChannel()&#10;        finish()&#10;    }&#10;&#10;    private fun leaveChannel() {&#10;        mRtcEngine?.leaveChannel()&#10;        mRtcEngine?.stopPreview()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        durationHandler?.removeCallbacks(durationRunnable!!)&#10;        leaveChannel()&#10;        RtcEngine.destroy()&#10;        mRtcEngine = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/utils/AgoraConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/utils/AgoraConfig.kt" />
              <option name="originalContent" value="package com.hamzatariq.i210396.utils&#10;&#10;object AgoraConfig {&#10;    // Agora App ID - Successfully configured!&#10;    const val APP_ID = &quot;fc45bacc392b45c58b8c0b3fc4e8b5e3&quot;&#10;&#10;    // Agora App Certificate (Primary Certificate)&#10;    // UNCOMMENT the line below when you enable token authentication in Agora Console&#10;    // For testing without token, keep this empty&#10;    const val APP_CERTIFICATE = &quot;&quot; // Set to &quot;0708667746bd4b8eb95ad1105e4b56fe&quot; for production&#10;&#10;    // Callback Secret&#10;    const val CALLBACK_SECRET = &quot;09999ad42b32a41002db5a46c39d025b&quot;&#10;&#10;    // Server URL&#10;    const val SERVER_URL = &quot;wss://webliveroom460418059-api.coolzcloud.com/ws&quot;&#10;&#10;    // Channel name will be generated dynamically for each call&#10;    fun generateChannelName(userId1: String, userId2: String): String {&#10;        return if (userId1 &lt; userId2) {&#10;            &quot;call_${userId1}_${userId2}&quot;&#10;        } else {&#10;            &quot;call_${userId2}_${userId1}&quot;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.i210396.utils&#10;&#10;object AgoraConfig {&#10;    // Agora App ID - Successfully configured!&#10;    const val APP_ID = &quot;fc45bacc392b45c58b8c0b3fc4e8b5e3&quot;&#10;&#10;    // Agora App Certificate (Primary Certificate)&#10;    // Enabled for token authentication&#10;    const val APP_CERTIFICATE = &quot;0708667746bd4b8eb95ad1105e4b56fe&quot;&#10;&#10;    // Callback Secret&#10;    const val CALLBACK_SECRET = &quot;09999ad42b32a41002db5a46c39d025b&quot;&#10;&#10;    // Server URL&#10;    const val SERVER_URL = &quot;wss://webliveroom460418059-api.coolzcloud.com/ws&quot;&#10;&#10;    // Channel name will be generated dynamically for each call&#10;    fun generateChannelName(userId1: String, userId2: String): String {&#10;        return if (userId1 &lt; userId2) {&#10;            &quot;call_${userId1}_${userId2}&quot;&#10;        } else {&#10;            &quot;call_${userId2}_${userId1}&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/utils/AgoraTokenGenerator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/utils/AgoraTokenGenerator.kt" />
              <option name="originalContent" value="package com.hamzatariq.i210396.utils&#10;&#10;import android.util.Base64&#10;import android.util.Log&#10;import java.nio.ByteBuffer&#10;import java.nio.ByteOrder&#10;import javax.crypto.Mac&#10;import javax.crypto.spec.SecretKeySpec&#10;import java.util.TreeMap&#10;import java.util.zip.CRC32&#10;&#10;object AgoraTokenGenerator {&#10;&#10;    private const val TAG = &quot;AgoraTokenGenerator&quot;&#10;&#10;    /**&#10;     * Generate Agora RTC token&#10;     * This is a simplified version - in production, use a backend server&#10;     */&#10;    fun generateToken(&#10;        channelName: String,&#10;        uid: Int,&#10;        role: Int = 1,&#10;        privilegeExpiredTs: Int = 0&#10;    ): String {&#10;        return try {&#10;            val appId = AgoraConfig.APP_ID&#10;            val appCertificate = AgoraConfig.APP_CERTIFICATE&#10;&#10;            if (appId.isEmpty() || appCertificate.isEmpty()) {&#10;                Log.e(TAG, &quot;App ID or Certificate is empty&quot;)&#10;                return &quot;&quot;&#10;            }&#10;&#10;            val privilegeExpired = if (privilegeExpiredTs == 0) {&#10;                (System.currentTimeMillis() / 1000 + 3600).toInt() // 1 hour&#10;            } else {&#10;                privilegeExpiredTs&#10;            }&#10;&#10;            Log.d(TAG, &quot;Generating token for channel: $channelName, uid: $uid&quot;)&#10;&#10;            val token = buildTokenWithUid(appId, appCertificate, channelName, uid, privilegeExpired)&#10;&#10;            Log.d(TAG, &quot;Token generated successfully, length: ${token.length}&quot;)&#10;            token&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to generate token: ${e.message}&quot;, e)&#10;            &quot;&quot;&#10;        }&#10;    }&#10;&#10;    fun getExpirationTimestamp(expirationTimeInSeconds: Int = 3600): Int {&#10;        return (System.currentTimeMillis() / 1000 + expirationTimeInSeconds).toInt()&#10;    }&#10;&#10;    private fun buildTokenWithUid(&#10;        appId: String,&#10;        appCertificate: String,&#10;        channelName: String,&#10;        uid: Int,&#10;        privilegeExpired: Int&#10;    ): String {&#10;        return AccessToken(appId, appCertificate, channelName, uid.toString()).apply {&#10;            addPrivilege(AccessToken.Privileges.kJoinChannel, privilegeExpired)&#10;            addPrivilege(AccessToken.Privileges.kPublishAudioStream, privilegeExpired)&#10;            addPrivilege(AccessToken.Privileges.kPublishVideoStream, privilegeExpired)&#10;            addPrivilege(AccessToken.Privileges.kPublishDataStream, privilegeExpired)&#10;        }.build()&#10;    }&#10;&#10;    // AccessToken implementation based on Agora's official algorithm&#10;    private class AccessToken(&#10;        private val appId: String,&#10;        private val appCertificate: String,&#10;        private val channelName: String,&#10;        private val uid: String&#10;    ) {&#10;        private val salt = (Math.random() * 99999999).toInt()&#10;        private val ts = (System.currentTimeMillis() / 1000).toInt()&#10;        private val messages = TreeMap&lt;Short, Int&gt;()&#10;&#10;        object Privileges {&#10;            const val kJoinChannel: Short = 1&#10;            const val kPublishAudioStream: Short = 2&#10;            const val kPublishVideoStream: Short = 3&#10;            const val kPublishDataStream: Short = 4&#10;        }&#10;&#10;        fun addPrivilege(privilege: Short, expireTimestamp: Int) {&#10;            messages[privilege] = expireTimestamp&#10;        }&#10;&#10;        fun build(): String {&#10;            val msg = pack()&#10;            val signature = hmacSign(appCertificate, msg)&#10;            val crcChannelName = crc32(channelName.toByteArray())&#10;            val crcUid = crc32(uid.toByteArray())&#10;&#10;            val content = packContent(signature, crcChannelName, crcUid, msg)&#10;            return &quot;007&quot; + Base64.encodeToString(content, Base64.NO_WRAP)&#10;        }&#10;&#10;        private fun pack(): ByteArray {&#10;            val buffer = ByteBuffer.allocate(1024)&#10;            buffer.order(ByteOrder.LITTLE_ENDIAN)&#10;&#10;            buffer.putInt(salt)&#10;            buffer.putInt(ts)&#10;            buffer.putInt(messages.size)&#10;&#10;            messages.forEach { (key, value) -&gt;&#10;                buffer.putShort(key)&#10;                buffer.putInt(value)&#10;            }&#10;&#10;            val messageBytes = ByteArray(buffer.position())&#10;            buffer.flip()&#10;            buffer.get(messageBytes)&#10;&#10;            return messageBytes&#10;        }&#10;&#10;        private fun packContent(&#10;            signature: ByteArray,&#10;            crcChannelName: Int,&#10;            crcUid: Int,&#10;            message: ByteArray&#10;        ): ByteArray {&#10;            val buffer = ByteBuffer.allocate(1024)&#10;            buffer.order(ByteOrder.LITTLE_ENDIAN)&#10;&#10;            // Pack signature&#10;            buffer.putShort(signature.size.toShort())&#10;            buffer.put(signature)&#10;&#10;            // Pack crc channel name&#10;            buffer.putInt(crcChannelName)&#10;&#10;            // Pack crc uid&#10;            buffer.putInt(crcUid)&#10;&#10;            // Pack message&#10;            buffer.putShort(message.size.toShort())&#10;            buffer.put(message)&#10;&#10;            val content = ByteArray(buffer.position())&#10;            buffer.flip()&#10;            buffer.get(content)&#10;&#10;            return content&#10;        }&#10;&#10;        private fun hmacSign(key: String, message: ByteArray): ByteArray {&#10;            val keySpec = SecretKeySpec(key.toByteArray(Charsets.UTF_8), &quot;HmacSHA256&quot;)&#10;            val mac = Mac.getInstance(&quot;HmacSHA256&quot;)&#10;            mac.init(keySpec)&#10;            return mac.doFinal(message)&#10;        }&#10;&#10;        private fun crc32(data: ByteArray): Int {&#10;            val crc = CRC32()&#10;            crc.update(data)&#10;            return crc.value.toInt()&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.i210396.utils&#10;&#10;import android.util.Base64&#10;import android.util.Log&#10;import java.nio.ByteBuffer&#10;import java.nio.ByteOrder&#10;import javax.crypto.Mac&#10;import javax.crypto.spec.SecretKeySpec&#10;import java.util.TreeMap&#10;import java.util.zip.CRC32&#10;&#10;object AgoraTokenGenerator {&#10;&#10;    private const val TAG = &quot;AgoraTokenGenerator&quot;&#10;    private const val VERSION = &quot;007&quot;&#10;&#10;    /**&#10;     * Generate Agora RTC token&#10;     * Based on Agora's official token generation algorithm&#10;     */&#10;    fun generateToken(&#10;        channelName: String,&#10;        uid: Int,&#10;        role: Int = 1,&#10;        privilegeExpiredTs: Int = 0&#10;    ): String {&#10;        return try {&#10;            val appId = AgoraConfig.APP_ID&#10;            val appCertificate = AgoraConfig.APP_CERTIFICATE&#10;&#10;            if (appId.isEmpty() || appCertificate.isEmpty()) {&#10;                Log.e(TAG, &quot;App ID or Certificate is empty&quot;)&#10;                Log.e(TAG, &quot;APP_ID: $appId&quot;)&#10;                Log.e(TAG, &quot;APP_CERTIFICATE length: ${appCertificate.length}&quot;)&#10;                return &quot;&quot;&#10;            }&#10;&#10;            // Calculate token expiration time (default 24 hours from now)&#10;            val tokenExpirationTs = if (privilegeExpiredTs == 0) {&#10;                (System.currentTimeMillis() / 1000 + 86400).toInt() // 24 hours&#10;            } else {&#10;                privilegeExpiredTs&#10;            }&#10;&#10;            Log.d(TAG, &quot;=== Token Generation Details ===&quot;)&#10;            Log.d(TAG, &quot;Channel: $channelName&quot;)&#10;            Log.d(TAG, &quot;UID: $uid&quot;)&#10;            Log.d(TAG, &quot;Token Expiration: $tokenExpirationTs&quot;)&#10;            Log.d(TAG, &quot;Current Time: ${System.currentTimeMillis() / 1000}&quot;)&#10;&#10;            val token = buildToken(appId, appCertificate, channelName, uid, tokenExpirationTs)&#10;&#10;            Log.d(TAG, &quot;Token generated successfully&quot;)&#10;            Log.d(TAG, &quot;Token length: ${token.length}&quot;)&#10;            Log.d(TAG, &quot;Token: $token&quot;)&#10;            &#10;            token&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to generate token: ${e.message}&quot;, e)&#10;            e.printStackTrace()&#10;            &quot;&quot;&#10;        }&#10;    }&#10;&#10;    private fun buildToken(&#10;        appId: String,&#10;        appCertificate: String,&#10;        channelName: String,&#10;        uid: Int,&#10;        privilegeExpiredTs: Int&#10;    ): String {&#10;        val uidStr = uid.toString()&#10;        val salt = (Math.random() * 99999999).toInt()&#10;        val ts = (System.currentTimeMillis() / 1000).toInt()&#10;&#10;        // Build privileges map&#10;        val messages = TreeMap&lt;Short, Int&gt;()&#10;        messages[1] = privilegeExpiredTs // kJoinChannel&#10;        messages[2] = privilegeExpiredTs // kPublishAudioStream&#10;        messages[3] = privilegeExpiredTs // kPublishVideoStream&#10;        messages[4] = privilegeExpiredTs // kPublishDataStream&#10;&#10;        // Pack message&#10;        val messageBuffer = ByteBuffer.allocate(1024).order(ByteOrder.LITTLE_ENDIAN)&#10;        messageBuffer.putInt(salt)&#10;        messageBuffer.putInt(ts)&#10;        messageBuffer.putInt(messages.size)&#10;&#10;        for ((privilege, expireTime) in messages) {&#10;            messageBuffer.putShort(privilege)&#10;            messageBuffer.putInt(expireTime)&#10;        }&#10;&#10;        val messageBytes = ByteArray(messageBuffer.position())&#10;        messageBuffer.flip()&#10;        messageBuffer.get(messageBytes)&#10;&#10;        // Generate signature&#10;        val signature = hmacSha256(appCertificate.toByteArray(Charsets.UTF_8), messageBytes)&#10;&#10;        // Calculate CRC32&#10;        val crcChannelName = crc32(channelName.toByteArray())&#10;        val crcUid = crc32(uidStr.toByteArray())&#10;&#10;        // Pack content&#10;        val contentBuffer = ByteBuffer.allocate(2048).order(ByteOrder.LITTLE_ENDIAN)&#10;        &#10;        // Signature&#10;        contentBuffer.putShort(signature.size.toShort())&#10;        contentBuffer.put(signature)&#10;        &#10;        // CRC channel name&#10;        contentBuffer.putInt(crcChannelName)&#10;        &#10;        // CRC UID&#10;        contentBuffer.putInt(crcUid)&#10;        &#10;        // Message&#10;        contentBuffer.putShort(messageBytes.size.toShort())&#10;        contentBuffer.put(messageBytes)&#10;&#10;        val contentBytes = ByteArray(contentBuffer.position())&#10;        contentBuffer.flip()&#10;        contentBuffer.get(contentBytes)&#10;&#10;        // Encode and build final token&#10;        val base64Content = Base64.encodeToString(contentBytes, Base64.NO_WRAP)&#10;        return VERSION + appId + base64Content&#10;    }&#10;&#10;    private fun hmacSha256(key: ByteArray, data: ByteArray): ByteArray {&#10;        val mac = Mac.getInstance(&quot;HmacSHA256&quot;)&#10;        val secretKeySpec = SecretKeySpec(key, &quot;HmacSHA256&quot;)&#10;        mac.init(secretKeySpec)&#10;        return mac.doFinal(data)&#10;    }&#10;&#10;    private fun crc32(data: ByteArray): Int {&#10;        val crc = CRC32()&#10;        crc.update(data)&#10;        return crc.value.toInt()&#10;    }&#10;&#10;    fun getExpirationTimestamp(expirationTimeInSeconds: Int = 3600): Int {&#10;        return (System.currentTimeMillis() / 1000 + expirationTimeInSeconds).toInt()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>