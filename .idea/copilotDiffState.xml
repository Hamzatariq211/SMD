<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="D:/agora-token-server/test-token-generation.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="D:/agora-token-server/test-token-generation.js" />
              <option name="updatedContent" value="#!/usr/bin/env node&#10;&#10;/**&#10; * Direct token testing script - bypasses HTTP layer&#10; * This helps diagnose if the problem is with the library or the HTTP handling&#10; */&#10;&#10;require('dotenv').config();&#10;const { RtcTokenBuilder, RtcRole } = require('agora-access-token');&#10;&#10;const APP_ID = &quot;fc45bacc392b45c58b8c0b3fc4e8b5e3&quot;;&#10;const APP_CERT = &quot;0708667746bd4b8eb95ad1105e4b56fe&quot;;&#10;&#10;console.log('\n=== AGORA TOKEN GENERATION TEST ===\n');&#10;&#10;// Test 1: Simple channel with underscores&#10;console.log('[Test 1] Simple channel: test_call');&#10;const testChannels = [&#10;  { name: 'test_call', uid: 12345 },&#10;  { name: 'call_5d002051_f2ab_4c7d_a4f7_c2f0f4e337d1_ec69436d_3b51_4833_a9d0_1bc5228d47b2', uid: 2113180218 },&#10;  { name: 'call_abc_def', uid: 999 }&#10;];&#10;&#10;testChannels.forEach((test, index) =&gt; {&#10;  try {&#10;    const now = Math.floor(Date.now() / 1000);&#10;    const expire = 3600;&#10;    const privilegeExpire = now + expire;&#10;&#10;    console.log(`\n[Test ${index + 1}] Generating token for: ${test.name}`);&#10;    console.log(`  ├─ UID: ${test.uid}`);&#10;    console.log(`  ├─ Role: PUBLISHER`);&#10;    console.log(`  ├─ Privilege Expire: ${privilegeExpire}`);&#10;&#10;    const token = RtcTokenBuilder.buildTokenWithUid(&#10;      APP_ID,&#10;      APP_CERT,&#10;      test.name,&#10;      test.uid,&#10;      RtcRole.PUBLISHER,&#10;      privilegeExpire&#10;    );&#10;&#10;    console.log(`  ├─ Token generated: YES`);&#10;    console.log(`  ├─ Token length: ${token.length}`);&#10;    console.log(`  ├─ Token format: ${token.substring(0, 3)}`);&#10;    console.log(`  ├─ Full token: ${token}`);&#10;    console.log(`  └─ Status: ✅ SUCCESS`);&#10;&#10;  } catch (e) {&#10;    console.error(`  └─ Status: ❌ ERROR - ${e.message}`);&#10;  }&#10;});&#10;&#10;console.log('\n=== TEST COMPLETE ===\n');&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.google.gms.google.services)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.devs.i210396_i211384&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.devs.i210396_i211384&quot;&#10;        minSdk = 26&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    lint {&#10;        abortOnError = false&#10;        checkReleaseBuilds = false&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.activity)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.firebase.auth)&#10;    implementation(libs.firebase.firestore)&#10;    implementation(libs.firebase.storage)&#10;    implementation(&quot;com.google.firebase:firebase-database:20.3.0&quot;) // Firebase Realtime Database for Stories&#10;    implementation(&quot;com.google.firebase:firebase-messaging:23.4.0&quot;) // Firebase Cloud Messaging&#10;&#10;    // Google Play Services&#10;    implementation(&quot;com.google.android.gms:play-services-base:18.5.0&quot;)&#10;&#10;    // CameraX dependencies&#10;    val cameraxVersion = &quot;1.3.0&quot;&#10;    implementation(&quot;androidx.camera:camera-core:$cameraxVersion&quot;)&#10;    implementation(&quot;androidx.camera:camera-camera2:$cameraxVersion&quot;)&#10;    implementation(&quot;androidx.camera:camera-lifecycle:$cameraxVersion&quot;)&#10;    implementation(&quot;androidx.camera:camera-view:1.2.3&quot;)&#10;    implementation(&quot;androidx.camera:camera-extensions:1.2.0&quot;)&#10;&#10;    // Agora Video SDK for real-time video/audio calls&#10;    implementation(&quot;io.agora.rtc:full-sdk:4.3.0&quot;)&#10;&#10;    // Retrofit for API calls&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#10;&#10;    // Coroutines&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.6.2&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;&#10;    androidTestImplementation (&quot;androidx.test.ext:junit:1.1.5&quot;)&#10;    androidTestImplementation (&quot;androidx.test.espresso:espresso-core:3.5.1&quot;)&#10;    androidTestImplementation (&quot;androidx.test.espresso:espresso-intents:3.5.1&quot;)&#10;&#10;    androidTestImplementation (&quot;androidx.test.espresso:espresso-contrib:3.5.1&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.google.gms.google.services)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.devs.i210396_i211384&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.devs.i210396_i211384&quot;&#10;        minSdk = 26&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    lint {&#10;        abortOnError = false&#10;        checkReleaseBuilds = false&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.activity)&#10;    implementation(libs.androidx.constraintlayout)&#10;    implementation(libs.firebase.auth)&#10;    implementation(libs.firebase.firestore)&#10;    implementation(libs.firebase.storage)&#10;    implementation(&quot;com.google.firebase:firebase-database:20.3.0&quot;) // Firebase Realtime Database for Stories&#10;    implementation(&quot;com.google.firebase:firebase-messaging:23.4.0&quot;) // Firebase Cloud Messaging&#10;&#10;    // Google Play Services&#10;    implementation(&quot;com.google.android.gms:play-services-base:18.5.0&quot;)&#10;&#10;    // CameraX dependencies&#10;    val cameraxVersion = &quot;1.3.0&quot;&#10;    implementation(&quot;androidx.camera:camera-core:$cameraxVersion&quot;)&#10;    implementation(&quot;androidx.camera:camera-camera2:$cameraxVersion&quot;)&#10;    implementation(&quot;androidx.camera:camera-lifecycle:$cameraxVersion&quot;)&#10;    implementation(&quot;androidx.camera:camera-view:1.2.3&quot;)&#10;    implementation(&quot;androidx.camera:camera-extensions:1.2.0&quot;)&#10;&#10;    // Agora Video SDK for real-time video/audio calls - Use the correct package name&#10;    implementation(&quot;io.agora.rtc:full-sdk:4.3.0&quot;)&#10;&#10;    // Retrofit for API calls&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#10;&#10;    // Coroutines&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.6.2&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;&#10;    androidTestImplementation (&quot;androidx.test.ext:junit:1.1.5&quot;)&#10;    androidTestImplementation (&quot;androidx.test.espresso:espresso-core:3.5.1&quot;)&#10;    androidTestImplementation (&quot;androidx.test.espresso:espresso-intents:3.5.1&quot;)&#10;&#10;    androidTestImplementation (&quot;androidx.test.espresso:espresso-contrib:3.5.1&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/androidTest/java/com/devs/i210396_i211384/PostCreationWorkflowTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/androidTest/java/com/devs/i210396_i211384/PostCreationWorkflowTest.kt" />
              <option name="originalContent" value="package com.devs.i210396_i211384&#10;&#10;import android.Manifest&#10;import androidx.test.espresso.Espresso.onView&#10;import androidx.test.espresso.action.ViewActions.*&#10;import androidx.test.espresso.assertion.ViewAssertions.matches&#10;import androidx.test.espresso.matcher.ViewMatchers.*&#10;import androidx.test.ext.junit.rules.ActivityScenarioRule&#10;import androidx.test.ext.junit.runners.AndroidJUnit4&#10;import androidx.test.filters.LargeTest&#10;import androidx.test.rule.GrantPermissionRule&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.database.FirebaseDatabase&#10;import org.junit.After&#10;import org.junit.Before&#10;import org.junit.Rule&#10;import org.junit.Test&#10;import org.junit.runner.RunWith&#10;&#10;/**&#10; * Espresso Test for Post Creation Workflow&#10; *&#10; * This test validates the critical post upload workflow including:&#10; * - Navigation to Add Post screen&#10; * - Image selection UI elements&#10; * - Caption input functionality&#10; * - Post submission&#10; * - Permission handling&#10; * - UI state management during post creation&#10; */&#10;@RunWith(AndroidJUnit4::class)&#10;@LargeTest&#10;class PostCreationWorkflowTest {&#10;&#10;    @get:Rule&#10;    val activityRule = ActivityScenarioRule(AddPostScreen::class.java)&#10;&#10;    @get:Rule&#10;    val permissionRule: GrantPermissionRule = GrantPermissionRule.grant(&#10;        Manifest.permission.CAMERA,&#10;        Manifest.permission.READ_MEDIA_IMAGES&#10;    )&#10;&#10;    private lateinit var auth: FirebaseAuth&#10;    private lateinit var database: FirebaseDatabase&#10;&#10;    @Before&#10;    fun setUp() {&#10;        // Initialize Firebase services&#10;        auth = FirebaseAuth.getInstance()&#10;        database = FirebaseDatabase.getInstance()&#10;&#10;        // Sign in a test user before each test (required for AddPostScreen)&#10;        // In a real scenario, you would sign in with actual test credentials&#10;        // For now, we just ensure Firebase is initialized&#10;        Thread.sleep(1500)&#10;    }&#10;&#10;    @After&#10;    fun tearDown() {&#10;        // Clean up any test data if needed&#10;    }&#10;&#10;    /**&#10;     * Test Case 1: Verify all Add Post UI elements are displayed&#10;     */&#10;    @Test&#10;    fun testAddPostScreenUIElementsDisplayed() {&#10;        // Verify back button is displayed&#10;        onView(withId(R.id.btnBack))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify post button is displayed&#10;        onView(withId(R.id.btnPost))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Post&quot;)))&#10;&#10;        // Verify image preview area is displayed&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify select image text is displayed initially&#10;        onView(withId(R.id.tvSelectImage))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Tap to select image&quot;)))&#10;&#10;        // Verify camera button is displayed&#10;        onView(withId(R.id.btnCamera))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Camera&quot;)))&#10;&#10;        // Verify gallery button is displayed&#10;        onView(withId(R.id.btnGallery))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Gallery&quot;)))&#10;&#10;        // Verify caption input is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withHint(&quot;Write a caption...&quot;)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 2: Verify back button navigation&#10;     */&#10;    @Test&#10;    fun testBackButtonNavigatesBack() {&#10;        // Click back button&#10;        onView(withId(R.id.btnBack))&#10;            .perform(click())&#10;&#10;        // Wait for navigation&#10;        Thread.sleep(1000)&#10;&#10;        // Activity should finish or navigate back&#10;        // Verification depends on activity lifecycle&#10;    }&#10;&#10;    /**&#10;     * Test Case 3: Verify caption input accepts text&#10;     */&#10;    @Test&#10;    fun testCaptionInputAcceptsText() {&#10;        val testCaption = &quot;This is a test post caption with #hashtags and @mentions&quot;&#10;&#10;        // Type caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(testCaption), closeSoftKeyboard())&#10;&#10;        // Wait briefly&#10;        Thread.sleep(500)&#10;&#10;        // Verify caption field is still displayed with text&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(testCaption)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 4: Verify caption can be cleared and re-entered&#10;     */&#10;    @Test&#10;    fun testCaptionCanBeClearedAndReentered() {&#10;        // Type initial caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(&quot;First caption&quot;), closeSoftKeyboard())&#10;&#10;        // Clear and type new caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(clearText(), typeText(&quot;Second caption&quot;), closeSoftKeyboard())&#10;&#10;        // Verify new caption is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(&quot;Second caption&quot;)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 5: Verify long caption input&#10;     */&#10;    @Test&#10;    fun testLongCaptionInput() {&#10;        val longCaption = &quot;This is a very long caption that contains multiple sentences. &quot; +&#10;                &quot;It tests the multiline capability of the EditText field. &quot; +&#10;                &quot;Instagram allows captions up to 2,200 characters, so we should support long text. &quot; +&#10;                &quot;This includes emojis , hashtags #test #longcaption, and mentions @user123.&quot;&#10;&#10;        // Type long caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(longCaption), closeSoftKeyboard())&#10;&#10;        // Wait briefly&#10;        Thread.sleep(500)&#10;&#10;        // Verify caption field accepts and displays long text&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 6: Verify camera button interaction&#10;     */&#10;    @Test&#10;    fun testCameraButtonClickable() {&#10;        // Scroll to camera button if needed&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;&#10;        // Click camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(click())&#10;&#10;        // Wait for camera intent or permission dialog&#10;        Thread.sleep(2000)&#10;&#10;        // Note: Camera intent will be launched, but in test environment&#10;        // it may not complete. This verifies the button is clickable.&#10;    }&#10;&#10;    /**&#10;     * Test Case 7: Verify gallery button interaction&#10;     */&#10;    @Test&#10;    fun testGalleryButtonClickable() {&#10;        // Scroll to gallery button if needed&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;&#10;        // Click gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(click())&#10;&#10;        // Wait for gallery intent&#10;        Thread.sleep(2000)&#10;&#10;        // Note: Gallery intent will be launched, but in test environment&#10;        // it may not complete. This verifies the button is clickable.&#10;    }&#10;&#10;    /**&#10;     * Test Case 8: Verify post button without image selection&#10;     */&#10;    @Test&#10;    fun testPostButtonWithoutImageShowsError() {&#10;        // Type caption only without selecting image&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(&quot;Caption without image&quot;), closeSoftKeyboard())&#10;&#10;        // Click post button&#10;        onView(withId(R.id.btnPost))&#10;            .perform(click())&#10;&#10;        // Wait for validation&#10;        Thread.sleep(1500)&#10;&#10;        // Verify user remains on add post screen (validation should prevent posting)&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify select image text is still visible (no image selected)&#10;        onView(withId(R.id.tvSelectImage))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 9: Verify post button without caption (should still work)&#10;     */&#10;    @Test&#10;    fun testPostButtonWithoutCaption() {&#10;        // Don't type any caption&#10;        // Note: In a real test, you'd mock image selection&#10;&#10;        // Click post button&#10;        onView(withId(R.id.btnPost))&#10;            .perform(click())&#10;&#10;        // Wait for validation&#10;        Thread.sleep(1500)&#10;&#10;        // Verify screen is still displayed&#10;        // (Should show error or allow posting without caption depending on implementation)&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 10: Verify UI elements are properly scrollable&#10;     */&#10;    @Test&#10;    fun testScreenIsScrollable() {&#10;        // Verify image preview is visible at top&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll down to caption field&#10;        onView(withId(R.id.etCaption))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll to camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll to gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 11: Verify caption with special characters&#10;     */&#10;    @Test&#10;    fun testCaptionWithSpecialCharacters() {&#10;        val specialCaption = &quot;Testing special chars: !@#$%^&amp;*()_+-=[]{}|;':\&quot;,./&lt;&gt;?&quot;&#10;&#10;        // Type caption with special characters&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(specialCaption), closeSoftKeyboard())&#10;&#10;        // Verify caption is accepted&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 12: Verify caption with numbers&#10;     */&#10;    @Test&#10;    fun testCaptionWithNumbers() {&#10;        val numericCaption = &quot;Post 123 - Testing numbers 456789&quot;&#10;&#10;        // Type caption with numbers&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(numericCaption), closeSoftKeyboard())&#10;&#10;        // Verify caption is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(numericCaption)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 13: Verify multiple clicks on camera button&#10;     */&#10;    @Test&#10;    fun testMultipleCameraButtonClicks() {&#10;        // Scroll to camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;&#10;        // Click camera button multiple times&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(click())&#10;&#10;        Thread.sleep(1000)&#10;&#10;        // Verify button is still displayed (no crash from multiple clicks)&#10;        onView(withId(R.id.btnCamera))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 14: Verify post button is visible and has correct styling&#10;     */&#10;    @Test&#10;    fun testPostButtonStyling() {&#10;        // Verify post button text and color&#10;        onView(withId(R.id.btnPost))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Post&quot;)))&#10;            .check(matches(isClickable()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 15: Test complete post creation workflow (simulated)&#10;     * Note: This simulates the flow without actual image selection&#10;     */&#10;    @Test&#10;    fun testCompletePostCreationWorkflow() {&#10;        // Step 1: Verify screen loaded&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Step 2: Add caption&#10;        val caption = &quot;Beautiful sunset  #nature #photography&quot;&#10;        onView(withId(R.id.etCaption))&#10;            .perform(typeText(caption), closeSoftKeyboard())&#10;&#10;        Thread.sleep(500)&#10;&#10;        // Step 3: Verify caption was entered&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(caption)))&#10;&#10;        // Step 4: Scroll to gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;&#10;        // Step 5: Click gallery button (would open image picker in real app)&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(click())&#10;&#10;        Thread.sleep(1000)&#10;&#10;        // Note: In a real test with mocked image selection,&#10;        // you would verify the image preview updates and then click post&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.devs.i210396_i211384&#10;&#10;import android.Manifest&#10;import androidx.test.espresso.Espresso.onView&#10;import androidx.test.espresso.action.ViewActions.*&#10;import androidx.test.espresso.assertion.ViewAssertions.matches&#10;import androidx.test.espresso.matcher.ViewMatchers.*&#10;import androidx.test.ext.junit.rules.ActivityScenarioRule&#10;import androidx.test.ext.junit.runners.AndroidJUnit4&#10;import androidx.test.filters.LargeTest&#10;import androidx.test.rule.GrantPermissionRule&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.database.FirebaseDatabase&#10;import org.junit.After&#10;import org.junit.Before&#10;import org.junit.Rule&#10;import org.junit.Test&#10;import org.junit.runner.RunWith&#10;&#10;/**&#10; * Espresso Test for Post Creation Workflow&#10; *&#10; * This test validates the critical post upload workflow including:&#10; * - Navigation to Add Post screen&#10; * - Image selection UI elements&#10; * - Caption input functionality&#10; * - Post submission&#10; * - Permission handling&#10; * - UI state management during post creation&#10; */&#10;@RunWith(AndroidJUnit4::class)&#10;@LargeTest&#10;class PostCreationWorkflowTest {&#10;&#10;    @get:Rule&#10;    val activityRule = ActivityScenarioRule(AddPostScreen::class.java)&#10;&#10;    @get:Rule&#10;    val permissionRule: GrantPermissionRule = GrantPermissionRule.grant(&#10;        Manifest.permission.CAMERA,&#10;        Manifest.permission.READ_MEDIA_IMAGES&#10;    )&#10;&#10;    private lateinit var auth: FirebaseAuth&#10;    private lateinit var database: FirebaseDatabase&#10;&#10;    @Before&#10;    fun setUp() {&#10;        // Initialize Firebase services&#10;        auth = FirebaseAuth.getInstance()&#10;        database = FirebaseDatabase.getInstance()&#10;&#10;        // Sign in a test user before each test (required for AddPostScreen)&#10;        // In a real scenario, you would sign in with actual test credentials&#10;        // For now, we just ensure Firebase is initialized&#10;        Thread.sleep(1500)&#10;    }&#10;&#10;    @After&#10;    fun tearDown() {&#10;        // Clean up any test data if needed&#10;    }&#10;&#10;    /**&#10;     * Test Case 1: Verify all Add Post UI elements are displayed&#10;     */&#10;    @Test&#10;    fun testAddPostScreenUIElementsDisplayed() {&#10;        // Verify back button is displayed&#10;        onView(withId(R.id.btnBack))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify post button is displayed&#10;        onView(withId(R.id.btnPost))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Post&quot;)))&#10;&#10;        // Verify image preview area is displayed&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify select image text is displayed initially&#10;        onView(withId(R.id.tvSelectImage))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Tap to select image&quot;)))&#10;&#10;        // Verify camera button is displayed&#10;        onView(withId(R.id.btnCamera))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Camera&quot;)))&#10;&#10;        // Verify gallery button is displayed&#10;        onView(withId(R.id.btnGallery))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Gallery&quot;)))&#10;&#10;        // Verify caption input is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withHint(&quot;Write a caption...&quot;)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 2: Verify back button navigation&#10;     */&#10;    @Test&#10;    fun testBackButtonNavigatesBack() {&#10;        // Click back button&#10;        onView(withId(R.id.btnBack))&#10;            .perform(click())&#10;&#10;        // Wait for navigation&#10;        Thread.sleep(1000)&#10;&#10;        // Activity should finish or navigate back&#10;        // Verification depends on activity lifecycle&#10;    }&#10;&#10;    /**&#10;     * Test Case 3: Verify caption input accepts text&#10;     */&#10;    @Test&#10;    fun testCaptionInputAcceptsText() {&#10;        val testCaption = &quot;This is a test post caption with #hashtags and @mentions&quot;&#10;&#10;        // Type caption using replaceText instead of typeText&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(testCaption), closeSoftKeyboard())&#10;&#10;        // Wait briefly&#10;        Thread.sleep(500)&#10;&#10;        // Verify caption field is still displayed with text&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(testCaption)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 4: Verify caption can be cleared and re-entered&#10;     */&#10;    @Test&#10;    fun testCaptionCanBeClearedAndReentered() {&#10;        // Type initial caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(&quot;First caption&quot;), closeSoftKeyboard())&#10;&#10;        // Clear and type new caption&#10;        onView(withId(R.id.etCaption))&#10;            .perform(clearText(), replaceText(&quot;Second caption&quot;), closeSoftKeyboard())&#10;&#10;        // Verify new caption is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(&quot;Second caption&quot;)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 5: Verify long caption input&#10;     */&#10;    @Test&#10;    fun testLongCaptionInput() {&#10;        val longCaption = &quot;This is a very long caption that contains multiple sentences. &quot; +&#10;                &quot;It tests the multiline capability of the EditText field. &quot; +&#10;                &quot;Instagram allows captions up to 2,200 characters, so we should support long text. &quot; +&#10;                &quot;This includes emojis, hashtags #test #longcaption, and mentions @user123.&quot;&#10;&#10;        // Type long caption using replaceText&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(longCaption), closeSoftKeyboard())&#10;&#10;        // Wait briefly&#10;        Thread.sleep(500)&#10;&#10;        // Verify caption field accepts and displays long text&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 6: Verify camera button interaction&#10;     */&#10;    @Test&#10;    fun testCameraButtonClickable() {&#10;        // Scroll to camera button if needed&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;&#10;        // Click camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(click())&#10;&#10;        // Wait for camera intent or permission dialog&#10;        Thread.sleep(2000)&#10;&#10;        // Note: Camera intent will be launched, but in test environment&#10;        // it may not complete. This verifies the button is clickable.&#10;    }&#10;&#10;    /**&#10;     * Test Case 7: Verify gallery button interaction&#10;     */&#10;    @Test&#10;    fun testGalleryButtonClickable() {&#10;        // Scroll to gallery button if needed&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;&#10;        // Click gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(click())&#10;&#10;        // Wait for gallery intent&#10;        Thread.sleep(2000)&#10;&#10;        // Note: Gallery intent will be launched, but in test environment&#10;        // it may not complete. This verifies the button is clickable.&#10;    }&#10;&#10;    /**&#10;     * Test Case 8: Verify post button without image selection&#10;     */&#10;    @Test&#10;    fun testPostButtonWithoutImageShowsError() {&#10;        // Type caption only without selecting image&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(&quot;Caption without image&quot;), closeSoftKeyboard())&#10;&#10;        // Click post button&#10;        onView(withId(R.id.btnPost))&#10;            .perform(click())&#10;&#10;        // Wait for validation&#10;        Thread.sleep(1500)&#10;&#10;        // Verify user remains on add post screen (validation should prevent posting)&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Verify select image text is still visible (no image selected)&#10;        onView(withId(R.id.tvSelectImage))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 9: Verify post button without caption (should still work)&#10;     */&#10;    @Test&#10;    fun testPostButtonWithoutCaption() {&#10;        // Don't type any caption&#10;        // Note: In a real test, you'd mock image selection&#10;&#10;        // Click post button&#10;        onView(withId(R.id.btnPost))&#10;            .perform(click())&#10;&#10;        // Wait for validation&#10;        Thread.sleep(1500)&#10;&#10;        // Verify screen is still displayed&#10;        // (Should show error or allow posting without caption depending on implementation)&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 10: Verify UI elements are properly scrollable&#10;     */&#10;    @Test&#10;    fun testScreenIsScrollable() {&#10;        // Verify image preview is visible at top&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll down to caption field&#10;        onView(withId(R.id.etCaption))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll to camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Scroll to gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 11: Verify caption with special characters&#10;     */&#10;    @Test&#10;    fun testCaptionWithSpecialCharacters() {&#10;        val specialCaption = &quot;Testing special chars: !@#$%^&amp;*()_+-=[]{}|;':\&quot;,./&lt;&gt;?&quot;&#10;&#10;        // Type caption with special characters using replaceText&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(specialCaption), closeSoftKeyboard())&#10;&#10;        // Verify caption is accepted&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(isDisplayed()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 12: Verify caption with numbers&#10;     */&#10;    @Test&#10;    fun testCaptionWithNumbers() {&#10;        val numericCaption = &quot;Post 123 - Testing numbers 456789&quot;&#10;&#10;        // Type caption with numbers using replaceText&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(numericCaption), closeSoftKeyboard())&#10;&#10;        // Verify caption is displayed&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(numericCaption)))&#10;    }&#10;&#10;    /**&#10;     * Test Case 13: Verify multiple clicks on camera button&#10;     */&#10;    @Test&#10;    fun testMultipleCameraButtonClicks() {&#10;        // Scroll to camera button&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(scrollTo())&#10;&#10;        // Verify camera button is displayed before clicking&#10;        onView(withId(R.id.btnCamera))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Click camera button (this will launch camera intent)&#10;        onView(withId(R.id.btnCamera))&#10;            .perform(click())&#10;&#10;        // Wait for camera intent to launch&#10;        Thread.sleep(1000)&#10;&#10;        // Note: After clicking camera button, camera intent is launched&#10;        // and the activity goes to background. We cannot verify UI elements&#10;        // after the camera intent is launched in a test environment.&#10;        // This test successfully verifies the button is clickable and doesn't crash.&#10;    }&#10;&#10;    /**&#10;     * Test Case 14: Verify post button is visible and has correct styling&#10;     */&#10;    @Test&#10;    fun testPostButtonStyling() {&#10;        // Verify post button text and color&#10;        onView(withId(R.id.btnPost))&#10;            .check(matches(isDisplayed()))&#10;            .check(matches(withText(&quot;Post&quot;)))&#10;            .check(matches(isClickable()))&#10;    }&#10;&#10;    /**&#10;     * Test Case 15: Test complete post creation workflow (simulated)&#10;     * Note: This simulates the flow without actual image selection&#10;     */&#10;    @Test&#10;    fun testCompletePostCreationWorkflow() {&#10;        // Step 1: Verify screen loaded&#10;        onView(withId(R.id.postImagePreview))&#10;            .check(matches(isDisplayed()))&#10;&#10;        // Step 2: Add caption (without emojis to avoid IME issues)&#10;        val caption = &quot;Beautiful sunset #nature #photography&quot;&#10;        onView(withId(R.id.etCaption))&#10;            .perform(replaceText(caption), closeSoftKeyboard())&#10;&#10;        Thread.sleep(500)&#10;&#10;        // Step 3: Verify caption was entered&#10;        onView(withId(R.id.etCaption))&#10;            .check(matches(withText(caption)))&#10;&#10;        // Step 4: Scroll to gallery button&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(scrollTo())&#10;&#10;        // Step 5: Click gallery button (would open image picker in real app)&#10;        onView(withId(R.id.btnGallery))&#10;            .perform(click())&#10;&#10;        Thread.sleep(1000)&#10;&#10;        // Note: In a real test with mocked image selection,&#10;        // you would verify the image preview updates and then click post&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/devs/i210396_i211384/callScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/devs/i210396_i211384/callScreen.kt" />
              <option name="originalContent" value="package com.devs.i210396_i211384&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.SurfaceView&#10;import android.view.View&#10;import android.widget.FrameLayout&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import com.devs.i210396_i211384.services.CallService&#10;import com.devs.i210396_i211384.utils.AgoraConfig&#10;import com.devs.i210396_i211384.utils.AgoraTokenGenerator&#10;import com.devs.i210396_i211384.utils.ImageUtils&#10;import io.agora.rtc2.ChannelMediaOptions&#10;import io.agora.rtc2.Constants&#10;import io.agora.rtc2.IRtcEngineEventHandler&#10;import io.agora.rtc2.RtcEngine&#10;import io.agora.rtc2.RtcEngineConfig&#10;import io.agora.rtc2.video.VideoCanvas&#10;&#10;class callScreen : AppCompatActivity() {&#10;    private var mRtcEngine: RtcEngine? = null&#10;    private lateinit var localVideoContainer: FrameLayout&#10;    private lateinit var remoteVideoContainer: FrameLayout&#10;    private lateinit var profileImage: ImageView&#10;    private lateinit var nameText: TextView&#10;    private lateinit var durationText: TextView&#10;    private lateinit var callStatusText: TextView&#10;&#10;    private var callId: String = &quot;&quot;&#10;    private var channelName: String = &quot;&quot;&#10;    private var callType: String = &quot;video&quot;&#10;    private var isIncoming: Boolean = false&#10;    private var otherUserId: String = &quot;&quot;&#10;    private var otherUserName: String = &quot;&quot;&#10;    private var otherUserImage: String = &quot;&quot;&#10;&#10;    private var isMuted = false&#10;    private var isSpeakerOn = true&#10;    private var isCameraOn = true&#10;    private var isFrontCamera = true&#10;&#10;    private var callStartTime: Long = 0&#10;    private var durationHandler: Handler? = null&#10;    private var durationRunnable: Runnable? = null&#10;    private var connectionTimeoutHandler: Handler? = null&#10;    private var isChannelJoined: Boolean = false&#10;&#10;    private val PERMISSION_REQ_ID = 22&#10;    private val REQUESTED_PERMISSIONS = arrayOf(&#10;        Manifest.permission.RECORD_AUDIO,&#10;        Manifest.permission.CAMERA&#10;    )&#10;    private val CONNECTION_TIMEOUT_MS = 30000L // 30 second timeout&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_call)&#10;&#10;        // Get call data&#10;        callId = intent.getStringExtra(&quot;callId&quot;) ?: &quot;&quot;&#10;        channelName = intent.getStringExtra(&quot;channelName&quot;) ?: &quot;&quot;&#10;        callType = intent.getStringExtra(&quot;callType&quot;) ?: &quot;video&quot;&#10;        isIncoming = intent.getBooleanExtra(&quot;isIncoming&quot;, false)&#10;        otherUserId = intent.getStringExtra(&quot;otherUserId&quot;) ?: &quot;&quot;&#10;        otherUserName = intent.getStringExtra(&quot;otherUserName&quot;) ?: &quot;User&quot;&#10;        otherUserImage = intent.getStringExtra(&quot;otherUserImage&quot;) ?: &quot;&quot;&#10;&#10;        android.util.Log.d(&quot;CallScreen&quot;, &quot;onCreate called - channelName: $channelName, callType: $callType&quot;)&#10;&#10;        initViews()&#10;&#10;        if (checkSelfPermission()) {&#10;            initializeAndJoinChannel()&#10;            // Start connection timeout&#10;            startConnectionTimeout()&#10;        }&#10;&#10;        setupCallStatusListener()&#10;    }&#10;&#10;    private fun startConnectionTimeout() {&#10;        connectionTimeoutHandler = Handler(Looper.getMainLooper())&#10;        connectionTimeoutHandler?.postDelayed({&#10;            if (!isChannelJoined) {&#10;                android.util.Log.e(&quot;CallScreen&quot;, &quot;Connection timeout - channel join failed&quot;)&#10;                Toast.makeText(this, &quot;Connection timeout. Please try again.&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }, CONNECTION_TIMEOUT_MS)&#10;    }&#10;&#10;    private fun cancelConnectionTimeout() {&#10;        connectionTimeoutHandler?.removeCallbacksAndMessages(null)&#10;        connectionTimeoutHandler = null&#10;    }&#10;&#10;    private fun initViews() {&#10;        localVideoContainer = findViewById(R.id.localVideoContainer)&#10;        remoteVideoContainer = findViewById(R.id.remoteVideoContainer)&#10;        profileImage = findViewById(R.id.ivProfile)&#10;        nameText = findViewById(R.id.tvName)&#10;        durationText = findViewById(R.id.tvDuration)&#10;        callStatusText = findViewById(R.id.tvCallStatus)&#10;&#10;        nameText.text = otherUserName&#10;        if (otherUserImage.isNotEmpty()) {&#10;            ImageUtils.loadBase64Image(profileImage, otherUserImage)&#10;        }&#10;&#10;        // Initially hide video containers for audio call&#10;        if (callType == &quot;audio&quot;) {&#10;            localVideoContainer.visibility = View.GONE&#10;            remoteVideoContainer.visibility = View.GONE&#10;            profileImage.visibility = View.VISIBLE&#10;        } else {&#10;            profileImage.visibility = View.GONE&#10;        }&#10;&#10;        callStatusText.text = if (isIncoming) &quot;Connecting...&quot; else &quot;Calling...&quot;&#10;        durationText.text = &quot;00:00&quot;&#10;&#10;        // Setup buttons&#10;        findViewById&lt;ImageView&gt;(R.id.ivEndCall).setOnClickListener {&#10;            endCall()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setOnClickListener {&#10;            toggleMute()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setOnClickListener {&#10;            toggleSpeaker()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSwitchCamera)?.setOnClickListener {&#10;            switchCamera()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setOnClickListener {&#10;            toggleVideo()&#10;        }&#10;    }&#10;&#10;    private fun checkSelfPermission(): Boolean {&#10;        val permissionsNeeded = REQUESTED_PERMISSIONS.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsNeeded.isNotEmpty()) {&#10;            ActivityCompat.requestPermissions(this, permissionsNeeded.toTypedArray(), PERMISSION_REQ_ID)&#10;            return false&#10;        }&#10;        return true&#10;    }&#10;&#10;    override fun onRequestPermissionsResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray&#10;    ) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == PERMISSION_REQ_ID) {&#10;            if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {&#10;                initializeAndJoinChannel()&#10;            } else {&#10;                Toast.makeText(this, &quot;Permissions required for call&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeAndJoinChannel() {&#10;        try {&#10;            // Validate APP_ID&#10;            if (AgoraConfig.APP_ID.isEmpty() || AgoraConfig.APP_ID.contains(&quot;YOUR_AGORA&quot;)) {&#10;                Toast.makeText(this, &quot;Invalid Agora App ID. Please check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            val config = RtcEngineConfig().apply {&#10;                mContext = applicationContext&#10;                mAppId = AgoraConfig.APP_ID&#10;                mEventHandler = rtcEventHandler&#10;            }&#10;&#10;            mRtcEngine = RtcEngine.create(config)&#10;&#10;            if (mRtcEngine == null) {&#10;                Toast.makeText(this, &quot;Failed to create RTC Engine&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            if (callType == &quot;video&quot;) {&#10;                mRtcEngine?.enableVideo()&#10;                setupLocalVideo()&#10;            } else {&#10;                mRtcEngine?.disableVideo()&#10;            }&#10;&#10;            mRtcEngine?.setDefaultAudioRoutetoSpeakerphone(true)&#10;&#10;            val options = ChannelMediaOptions().apply {&#10;                channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION&#10;                clientRoleType = Constants.CLIENT_ROLE_BROADCASTER&#10;            }&#10;&#10;            // Generate unique UID based on user ID&#10;            val uid = otherUserId.hashCode() and 0x7FFFFFFF&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;=== TOKEN FETCH FROM SERVER ===&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;APP_ID: ${AgoraConfig.APP_ID}&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel Name: $channelName&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;UID: $uid&quot;)&#10;&#10;            // Fetch token from server instead of generating locally&#10;            fetchTokenFromServer(channelName, uid, options)&#10;&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            android.util.Log.e(&quot;CallScreen&quot;, &quot;Exception in initializeAndJoinChannel: ${e.message}&quot;)&#10;            Toast.makeText(this, &quot;Failed to initialize call: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun fetchTokenFromServer(channelName: String, uid: Int, options: ChannelMediaOptions) {&#10;        // CRITICAL FIX: Channel name must be alphanumeric and underscore only for Agora&#10;        // The current channel name has hyphens and underscores which may cause issues&#10;        val sanitizedChannelName = channelName.replace(&quot;-&quot;, &quot;_&quot;)&#10;&#10;        // Fetch token from your running token server (port 8080)&#10;        // Correct endpoint: /rtcToken?channel={channelName}&amp;uid={uid}&amp;role=publisher&amp;expire=3600&#10;        val tokenServerUrl = &quot;http://10.0.2.2:8080/rtcToken?channel=$sanitizedChannelName&amp;uid=$uid&amp;role=publisher&amp;expire=3600&quot;&#10;&#10;        android.util.Log.d(&quot;CallScreen&quot;, &quot;Original channel: $channelName&quot;)&#10;        android.util.Log.d(&quot;CallScreen&quot;, &quot;Sanitized channel: $sanitizedChannelName&quot;)&#10;        android.util.Log.d(&quot;CallScreen&quot;, &quot;Fetching token from: $tokenServerUrl&quot;)&#10;&#10;        Thread {&#10;            try {&#10;                val url = java.net.URL(tokenServerUrl)&#10;                val connection = url.openConnection() as java.net.HttpURLConnection&#10;                connection.requestMethod = &quot;GET&quot;&#10;                connection.connectTimeout = 10000&#10;                connection.readTimeout = 10000&#10;&#10;                val responseCode = connection.responseCode&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token server response code: $responseCode&quot;)&#10;&#10;                if (responseCode == 200) {&#10;                    val inputStream = connection.inputStream&#10;                    val response = inputStream.bufferedReader().use { it.readText() }&#10;                    android.util.Log.d(&quot;CallScreen&quot;, &quot;Token server raw response: $response&quot;)&#10;&#10;                    // Parse JSON response to get token&#10;                    val token = try {&#10;                        val jsonObject = org.json.JSONObject(response)&#10;                        jsonObject.getString(&quot;token&quot;)&#10;                    } catch (e: Exception) {&#10;                        android.util.Log.e(&quot;CallScreen&quot;, &quot;Failed to parse JSON response: ${e.message}&quot;)&#10;                        &quot;&quot;&#10;                    }&#10;&#10;                    if (token.isNotEmpty() &amp;&amp; token.length &gt; 50) {&#10;                        android.util.Log.d(&quot;CallScreen&quot;, &quot;✅ Token fetched successfully!&quot;)&#10;                        android.util.Log.d(&quot;CallScreen&quot;, &quot;Token length: ${token.length}&quot;)&#10;                        android.util.Log.d(&quot;CallScreen&quot;, &quot;Token preview: ${token.take(50)}...&quot;)&#10;                        android.util.Log.d(&quot;CallScreen&quot;, &quot;Token full: $token&quot;)&#10;&#10;                        // Add a small delay to ensure RtcEngine is ready&#10;                        Thread.sleep(500)&#10;&#10;                        joinChannelWithToken(token, sanitizedChannelName, uid, options)&#10;                    } else {&#10;                        android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Invalid token received. Length: ${token.length}&quot;)&#10;                        runOnUiThread {&#10;                            Toast.makeText(this@callScreen, &quot;Invalid token from server&quot;, Toast.LENGTH_SHORT).show()&#10;                            finish()&#10;                        }&#10;                    }&#10;                } else {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Failed to fetch token: HTTP $responseCode&quot;)&#10;                    val errorStream = connection.errorStream&#10;                    val errorResponse = errorStream?.bufferedReader()?.use { it.readText() } ?: &quot;Unknown error&quot;&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;Error response: $errorResponse&quot;)&#10;&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@callScreen, &quot;Failed to fetch token (HTTP $responseCode)&quot;, Toast.LENGTH_SHORT).show()&#10;                        finish()&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Exception fetching token: ${e.message}&quot;, e)&#10;                e.printStackTrace()&#10;                runOnUiThread {&#10;                    Toast.makeText(this@callScreen, &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun joinChannelWithToken(token: String, channelName: String, uid: Int, options: ChannelMediaOptions) {&#10;        runOnUiThread {&#10;            try {&#10;                // Final validation before joining&#10;                if (mRtcEngine == null) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ RtcEngine is null! Cannot join channel&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Engine not initialized&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@runOnUiThread&#10;                }&#10;&#10;                if (token.isEmpty()) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Token is empty!&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Invalid token&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@runOnUiThread&#10;                }&#10;&#10;                if (channelName.isEmpty()) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Channel name is empty!&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Invalid channel&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@runOnUiThread&#10;                }&#10;&#10;                if (uid &lt;= 0) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ UID is invalid: $uid&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Invalid UID&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@runOnUiThread&#10;                }&#10;&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;=== JOINING CHANNEL ===&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel: $channelName&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;UID: $uid&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token length: ${token.length}&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token starts with: ${token.take(20)}...&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token ends with: ...${token.takeLast(20)}&quot;)&#10;&#10;                val result = mRtcEngine?.joinChannel(token, channelName, uid, options)&#10;&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;joinChannel result: $result&quot;)&#10;&#10;                if (result != 0) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ joinChannel failed with error code: $result&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;Error meanings:&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;  -102 = Token invalid or credentials mismatch&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;  -3 = Invalid channel name&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;  -8 = Not initialized&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Failed to join channel. Error code: $result&quot;, Toast.LENGTH_LONG).show()&#10;                    finish()&#10;                } else {&#10;                    android.util.Log.d(&quot;CallScreen&quot;, &quot;✅ joinChannel call successful, waiting for callback...&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                android.util.Log.e(&quot;CallScreen&quot;, &quot;Exception in joinChannelWithToken: ${e.message}&quot;, e)&#10;                Toast.makeText(this@callScreen, &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupLocalVideo() {&#10;        val surfaceView = SurfaceView(this)&#10;        localVideoContainer.addView(surfaceView)&#10;        mRtcEngine?.setupLocalVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, 0))&#10;        mRtcEngine?.startPreview()&#10;    }&#10;&#10;    private fun setupRemoteVideo(uid: Int) {&#10;        runOnUiThread {&#10;            if (callType == &quot;video&quot;) {&#10;                profileImage.visibility = View.GONE&#10;                remoteVideoContainer.visibility = View.VISIBLE&#10;&#10;                val surfaceView = SurfaceView(this)&#10;                remoteVideoContainer.addView(surfaceView)&#10;                mRtcEngine?.setupRemoteVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, uid))&#10;            }&#10;&#10;            callStatusText.visibility = View.GONE&#10;            startCallDuration()&#10;        }&#10;    }&#10;&#10;    private val rtcEventHandler = object : IRtcEngineEventHandler() {&#10;        override fun onUserJoined(uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                setupRemoteVideo(uid)&#10;            }&#10;        }&#10;&#10;        override fun onUserOffline(uid: Int, reason: Int) {&#10;            runOnUiThread {&#10;                remoteVideoContainer.removeAllViews()&#10;                endCall()&#10;            }&#10;        }&#10;&#10;        override fun onJoinChannelSuccess(channel: String?, uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                callStatusText.text = &quot;Connected&quot;&#10;                isChannelJoined = true&#10;                // Cancel connection timeout&#10;                cancelConnectionTimeout()&#10;            }&#10;        }&#10;&#10;        override fun onError(err: Int) {&#10;            runOnUiThread {&#10;                Toast.makeText(this@callScreen, &quot;Call error: $err&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun toggleMute() {&#10;        isMuted = !isMuted&#10;        mRtcEngine?.muteLocalAudioStream(isMuted)&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setImageResource(&#10;            if (isMuted) R.drawable.ic_mic_off else R.drawable.ic_mic_on&#10;        )&#10;    }&#10;&#10;    private fun toggleSpeaker() {&#10;        isSpeakerOn = !isSpeakerOn&#10;        mRtcEngine?.setEnableSpeakerphone(isSpeakerOn)&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setImageResource(&#10;            if (isSpeakerOn) R.drawable.speaker else R.drawable.ic_speaker_off&#10;        )&#10;    }&#10;&#10;    private fun switchCamera() {&#10;        if (callType == &quot;video&quot;) {&#10;            mRtcEngine?.switchCamera()&#10;            isFrontCamera = !isFrontCamera&#10;        }&#10;    }&#10;&#10;    private fun toggleVideo() {&#10;        if (callType == &quot;video&quot;) {&#10;            isCameraOn = !isCameraOn&#10;            mRtcEngine?.muteLocalVideoStream(!isCameraOn)&#10;            localVideoContainer.visibility = if (isCameraOn) View.VISIBLE else View.GONE&#10;            findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setImageResource(&#10;                if (isCameraOn) R.drawable.ic_video_on else R.drawable.ic_video_off&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun startCallDuration() {&#10;        callStartTime = System.currentTimeMillis()&#10;        durationHandler = Handler(Looper.getMainLooper())&#10;        durationRunnable = object : Runnable {&#10;            override fun run() {&#10;                val elapsed = (System.currentTimeMillis() - callStartTime) / 1000&#10;                val minutes = elapsed / 60&#10;                val seconds = elapsed % 60&#10;                durationText.text = String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;                durationHandler?.postDelayed(this, 1000)&#10;            }&#10;        }&#10;        durationHandler?.post(durationRunnable!!)&#10;    }&#10;&#10;    private fun setupCallStatusListener() {&#10;        CallService.listenToCallStatus(callId) { status -&gt;&#10;            runOnUiThread {&#10;                when (status) {&#10;                    &quot;rejected&quot; -&gt; {&#10;                        Toast.makeText(this, &quot;Call rejected&quot;, Toast.LENGTH_SHORT).show()&#10;                        finish()&#10;                    }&#10;                    &quot;ended&quot; -&gt; {&#10;                        finish()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endCall() {&#10;        CallService.updateCallStatus(callId, &quot;ended&quot;)&#10;        CallService.endCall(callId)&#10;        leaveChannel()&#10;        finish()&#10;    }&#10;&#10;    private fun leaveChannel() {&#10;        mRtcEngine?.leaveChannel()&#10;        mRtcEngine?.stopPreview()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        durationHandler?.removeCallbacks(durationRunnable!!)&#10;        leaveChannel()&#10;        RtcEngine.destroy()&#10;        mRtcEngine = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.devs.i210396_i211384&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.SurfaceView&#10;import android.view.View&#10;import android.widget.FrameLayout&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import com.devs.i210396_i211384.services.CallService&#10;import com.devs.i210396_i211384.utils.AgoraConfig&#10;import com.devs.i210396_i211384.utils.AgoraTokenGenerator&#10;import com.devs.i210396_i211384.utils.ImageUtils&#10;import io.agora.rtc2.ChannelMediaOptions&#10;import io.agora.rtc2.Constants&#10;import io.agora.rtc2.IRtcEngineEventHandler&#10;import io.agora.rtc2.RtcEngine&#10;import io.agora.rtc2.RtcEngineConfig&#10;import io.agora.rtc2.video.VideoCanvas&#10;&#10;class callScreen : AppCompatActivity() {&#10;    private var mRtcEngine: RtcEngine? = null&#10;    private lateinit var localVideoContainer: FrameLayout&#10;    private lateinit var remoteVideoContainer: FrameLayout&#10;    private lateinit var profileImage: ImageView&#10;    private lateinit var nameText: TextView&#10;    private lateinit var durationText: TextView&#10;    private lateinit var callStatusText: TextView&#10;&#10;    private var callId: String = &quot;&quot;&#10;    private var channelName: String = &quot;&quot;&#10;    private var callType: String = &quot;video&quot;&#10;    private var isIncoming: Boolean = false&#10;    private var otherUserId: String = &quot;&quot;&#10;    private var otherUserName: String = &quot;&quot;&#10;    private var otherUserImage: String = &quot;&quot;&#10;&#10;    private var isMuted = false&#10;    private var isSpeakerOn = true&#10;    private var isCameraOn = true&#10;    private var isFrontCamera = true&#10;&#10;    private var callStartTime: Long = 0&#10;    private var durationHandler: Handler? = null&#10;    private var durationRunnable: Runnable? = null&#10;    private var connectionTimeoutHandler: Handler? = null&#10;    private var isChannelJoined: Boolean = false&#10;&#10;    private val PERMISSION_REQ_ID = 22&#10;    private val REQUESTED_PERMISSIONS = arrayOf(&#10;        Manifest.permission.RECORD_AUDIO,&#10;        Manifest.permission.CAMERA&#10;    )&#10;    private val CONNECTION_TIMEOUT_MS = 30000L // 30 second timeout&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_call)&#10;&#10;        // Get call data&#10;        callId = intent.getStringExtra(&quot;callId&quot;) ?: &quot;&quot;&#10;        channelName = intent.getStringExtra(&quot;channelName&quot;) ?: &quot;&quot;&#10;        &#10;        // CRITICAL FIX: Sanitize channel name IMMEDIATELY - this is what the token will be generated for&#10;        channelName = channelName.replace(&quot;-&quot;, &quot;_&quot;)&#10;        &#10;        callType = intent.getStringExtra(&quot;callType&quot;) ?: &quot;video&quot;&#10;        isIncoming = intent.getBooleanExtra(&quot;isIncoming&quot;, false)&#10;        otherUserId = intent.getStringExtra(&quot;otherUserId&quot;) ?: &quot;&quot;&#10;        otherUserName = intent.getStringExtra(&quot;otherUserName&quot;) ?: &quot;User&quot;&#10;        otherUserImage = intent.getStringExtra(&quot;otherUserImage&quot;) ?: &quot;&quot;&#10;&#10;        android.util.Log.d(&quot;CallScreen&quot;, &quot;onCreate called - channelName: $channelName, callType: $callType&quot;)&#10;&#10;        initViews()&#10;&#10;        if (checkSelfPermission()) {&#10;            initializeAndJoinChannel()&#10;            // Start connection timeout&#10;            startConnectionTimeout()&#10;        }&#10;&#10;        setupCallStatusListener()&#10;    }&#10;&#10;    private fun startConnectionTimeout() {&#10;        connectionTimeoutHandler = Handler(Looper.getMainLooper())&#10;        connectionTimeoutHandler?.postDelayed({&#10;            if (!isChannelJoined) {&#10;                android.util.Log.e(&quot;CallScreen&quot;, &quot;Connection timeout - channel join failed&quot;)&#10;                Toast.makeText(this, &quot;Connection timeout. Please try again.&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }, CONNECTION_TIMEOUT_MS)&#10;    }&#10;&#10;    private fun cancelConnectionTimeout() {&#10;        connectionTimeoutHandler?.removeCallbacksAndMessages(null)&#10;        connectionTimeoutHandler = null&#10;    }&#10;&#10;    private fun initViews() {&#10;        localVideoContainer = findViewById(R.id.localVideoContainer)&#10;        remoteVideoContainer = findViewById(R.id.remoteVideoContainer)&#10;        profileImage = findViewById(R.id.ivProfile)&#10;        nameText = findViewById(R.id.tvName)&#10;        durationText = findViewById(R.id.tvDuration)&#10;        callStatusText = findViewById(R.id.tvCallStatus)&#10;&#10;        nameText.text = otherUserName&#10;        if (otherUserImage.isNotEmpty()) {&#10;            ImageUtils.loadBase64Image(profileImage, otherUserImage)&#10;        }&#10;&#10;        // Initially hide video containers for audio call&#10;        if (callType == &quot;audio&quot;) {&#10;            localVideoContainer.visibility = View.GONE&#10;            remoteVideoContainer.visibility = View.GONE&#10;            profileImage.visibility = View.VISIBLE&#10;        } else {&#10;            profileImage.visibility = View.GONE&#10;        }&#10;&#10;        callStatusText.text = if (isIncoming) &quot;Connecting...&quot; else &quot;Calling...&quot;&#10;        durationText.text = &quot;00:00&quot;&#10;&#10;        // Setup buttons&#10;        findViewById&lt;ImageView&gt;(R.id.ivEndCall).setOnClickListener {&#10;            endCall()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setOnClickListener {&#10;            toggleMute()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setOnClickListener {&#10;            toggleSpeaker()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSwitchCamera)?.setOnClickListener {&#10;            switchCamera()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setOnClickListener {&#10;            toggleVideo()&#10;        }&#10;    }&#10;&#10;    private fun checkSelfPermission(): Boolean {&#10;        val permissionsNeeded = REQUESTED_PERMISSIONS.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsNeeded.isNotEmpty()) {&#10;            ActivityCompat.requestPermissions(this, permissionsNeeded.toTypedArray(), PERMISSION_REQ_ID)&#10;            return false&#10;        }&#10;        return true&#10;    }&#10;&#10;    override fun onRequestPermissionsResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray&#10;    ) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == PERMISSION_REQ_ID) {&#10;            if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {&#10;                initializeAndJoinChannel()&#10;            } else {&#10;                Toast.makeText(this, &quot;Permissions required for call&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeAndJoinChannel() {&#10;        try {&#10;            // Validate APP_ID&#10;            if (AgoraConfig.APP_ID.isEmpty() || AgoraConfig.APP_ID.contains(&quot;YOUR_AGORA&quot;)) {&#10;                Toast.makeText(this, &quot;Invalid Agora App ID. Please check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            val config = RtcEngineConfig().apply {&#10;                mContext = applicationContext&#10;                mAppId = AgoraConfig.APP_ID&#10;                mEventHandler = rtcEventHandler&#10;            }&#10;&#10;            mRtcEngine = RtcEngine.create(config)&#10;&#10;            if (mRtcEngine == null) {&#10;                Toast.makeText(this, &quot;Failed to create RTC Engine&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            if (callType == &quot;video&quot;) {&#10;                mRtcEngine?.enableVideo()&#10;                setupLocalVideo()&#10;            } else {&#10;                mRtcEngine?.disableVideo()&#10;            }&#10;&#10;            mRtcEngine?.setDefaultAudioRoutetoSpeakerphone(true)&#10;&#10;            val options = ChannelMediaOptions().apply {&#10;                channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION&#10;                clientRoleType = Constants.CLIENT_ROLE_BROADCASTER&#10;            }&#10;&#10;            // Generate unique UID based on user ID&#10;            val uid = otherUserId.hashCode() and 0x7FFFFFFF&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;=== TOKEN FETCH FROM SERVER ===&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;APP_ID: ${AgoraConfig.APP_ID}&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel Name (sanitized): $channelName&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;UID: $uid&quot;)&#10;&#10;            // Fetch token from server using SANITIZED channel name&#10;            // CRITICAL: Token will be generated for this exact channel name&#10;            fetchTokenFromServer(channelName, uid, options)&#10;&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            android.util.Log.e(&quot;CallScreen&quot;, &quot;Exception in initializeAndJoinChannel: ${e.message}&quot;)&#10;            Toast.makeText(this, &quot;Failed to initialize call: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun fetchTokenFromServer(channelName: String, uid: Int, options: ChannelMediaOptions) {&#10;        // CRITICAL: channelName is ALREADY SANITIZED in onCreate()&#10;        // Do NOT sanitize again here - it's already been done&#10;        &#10;        // Fetch token from your running token server (port 8080)&#10;        val tokenServerUrl = &quot;http://10.0.2.2:8080/rtcToken?channel=$channelName&amp;uid=$uid&amp;role=publisher&amp;expire=3600&quot;&#10;&#10;        android.util.Log.d(&quot;CallScreen&quot;, &quot;Final channel name: $channelName&quot;)&#10;        android.util.Log.d(&quot;CallScreen&quot;, &quot;Fetching token from: $tokenServerUrl&quot;)&#10;&#10;        Thread {&#10;            try {&#10;                val url = java.net.URL(tokenServerUrl)&#10;                val connection = url.openConnection() as java.net.HttpURLConnection&#10;                connection.requestMethod = &quot;GET&quot;&#10;                connection.connectTimeout = 10000&#10;                connection.readTimeout = 10000&#10;&#10;                val responseCode = connection.responseCode&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token server response code: $responseCode&quot;)&#10;&#10;                if (responseCode == 200) {&#10;                    val inputStream = connection.inputStream&#10;                    val response = inputStream.bufferedReader().use { it.readText() }&#10;                    android.util.Log.d(&quot;CallScreen&quot;, &quot;Token server raw response: $response&quot;)&#10;&#10;                    // Parse JSON response to get token&#10;                    val token = try {&#10;                        val jsonObject = org.json.JSONObject(response)&#10;                        jsonObject.getString(&quot;token&quot;)&#10;                    } catch (e: Exception) {&#10;                        android.util.Log.e(&quot;CallScreen&quot;, &quot;Failed to parse JSON response: ${e.message}&quot;)&#10;                        &quot;&quot;&#10;                    }&#10;&#10;                    if (token.isNotEmpty() &amp;&amp; token.length &gt; 50) {&#10;                        android.util.Log.d(&quot;CallScreen&quot;, &quot;✅ Token fetched successfully!&quot;)&#10;                        android.util.Log.d(&quot;CallScreen&quot;, &quot;Token length: ${token.length}&quot;)&#10;                        android.util.Log.d(&quot;CallScreen&quot;, &quot;Token preview: ${token.take(50)}...&quot;)&#10;                        android.util.Log.d(&quot;CallScreen&quot;, &quot;Token full: $token&quot;)&#10;                        &#10;                        // Add delay to ensure RtcEngine is ready&#10;                        Thread.sleep(500)&#10;                        &#10;                        // CRITICAL: Join with SAME channel name used for token generation&#10;                        joinChannelWithToken(token, channelName, uid, options)&#10;                    } else {&#10;                        android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Invalid token received. Length: ${token.length}&quot;)&#10;                        runOnUiThread {&#10;                            Toast.makeText(this@callScreen, &quot;Invalid token from server&quot;, Toast.LENGTH_SHORT).show()&#10;                            finish()&#10;                        }&#10;                    }&#10;                } else {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Failed to fetch token: HTTP $responseCode&quot;)&#10;                    val errorStream = connection.errorStream&#10;                    val errorResponse = errorStream?.bufferedReader()?.use { it.readText() } ?: &quot;Unknown error&quot;&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;Error response: $errorResponse&quot;)&#10;&#10;                    runOnUiThread {&#10;                        Toast.makeText(this@callScreen, &quot;Failed to fetch token (HTTP $responseCode)&quot;, Toast.LENGTH_SHORT).show()&#10;                        finish()&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Exception fetching token: ${e.message}&quot;, e)&#10;                e.printStackTrace()&#10;                runOnUiThread {&#10;                    Toast.makeText(this@callScreen, &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun joinChannelWithToken(token: String, channelName: String, uid: Int, options: ChannelMediaOptions) {&#10;        runOnUiThread {&#10;            try {&#10;                // Final validation before joining&#10;                if (mRtcEngine == null) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ RtcEngine is null! Cannot join channel&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Engine not initialized&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@runOnUiThread&#10;                }&#10;&#10;                if (token.isEmpty()) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Token is empty!&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Invalid token&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@runOnUiThread&#10;                }&#10;&#10;                if (channelName.isEmpty()) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ Channel name is empty!&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Invalid channel&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@runOnUiThread&#10;                }&#10;&#10;                if (uid &lt;= 0) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ UID is invalid: $uid&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Invalid UID&quot;, Toast.LENGTH_SHORT).show()&#10;                    finish()&#10;                    return@runOnUiThread&#10;                }&#10;&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;=== JOINING CHANNEL ===&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel: $channelName&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;UID: $uid&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token length: ${token.length}&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token starts with: ${token.take(20)}...&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token ends with: ...${token.takeLast(20)}&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token format check: ${token.substring(0, 3)} (should be 007 or 006)&quot;)&#10;&#10;                val result = mRtcEngine?.joinChannel(token, channelName, uid, options)&#10;&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;joinChannel result: $result&quot;)&#10;&#10;                if (result != 0) {&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;❌ joinChannel failed with error code: $result&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;Error meanings:&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;  -102 = Token invalid or channel mismatch&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;  -3 = Invalid channel name&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;  -8 = Engine not initialized&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;VERIFICATION:&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;  - Token starts with 007 or 006: ${token.substring(0, 3)}&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;  - Channel name: $channelName&quot;)&#10;                    android.util.Log.e(&quot;CallScreen&quot;, &quot;  - UID: $uid&quot;)&#10;                    Toast.makeText(this@callScreen, &quot;Failed to join channel. Error code: $result&quot;, Toast.LENGTH_LONG).show()&#10;                    finish()&#10;                } else {&#10;                    android.util.Log.d(&quot;CallScreen&quot;, &quot;✅ joinChannel call successful, waiting for callback...&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                android.util.Log.e(&quot;CallScreen&quot;, &quot;Exception in joinChannelWithToken: ${e.message}&quot;, e)&#10;                Toast.makeText(this@callScreen, &quot;Error: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupLocalVideo() {&#10;        val surfaceView = SurfaceView(this)&#10;        localVideoContainer.addView(surfaceView)&#10;        mRtcEngine?.setupLocalVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, 0))&#10;        mRtcEngine?.startPreview()&#10;    }&#10;&#10;    private fun setupRemoteVideo(uid: Int) {&#10;        runOnUiThread {&#10;            if (callType == &quot;video&quot;) {&#10;                profileImage.visibility = View.GONE&#10;                remoteVideoContainer.visibility = View.VISIBLE&#10;&#10;                val surfaceView = SurfaceView(this)&#10;                remoteVideoContainer.addView(surfaceView)&#10;                mRtcEngine?.setupRemoteVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, uid))&#10;            }&#10;&#10;            callStatusText.visibility = View.GONE&#10;            startCallDuration()&#10;        }&#10;    }&#10;&#10;    private val rtcEventHandler = object : IRtcEngineEventHandler() {&#10;        override fun onUserJoined(uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                setupRemoteVideo(uid)&#10;            }&#10;        }&#10;&#10;        override fun onUserOffline(uid: Int, reason: Int) {&#10;            runOnUiThread {&#10;                remoteVideoContainer.removeAllViews()&#10;                endCall()&#10;            }&#10;        }&#10;&#10;        override fun onJoinChannelSuccess(channel: String?, uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                callStatusText.text = &quot;Connected&quot;&#10;                isChannelJoined = true&#10;                // Cancel connection timeout&#10;                cancelConnectionTimeout()&#10;            }&#10;        }&#10;&#10;        override fun onError(err: Int) {&#10;            runOnUiThread {&#10;                Toast.makeText(this@callScreen, &quot;Call error: $err&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun toggleMute() {&#10;        isMuted = !isMuted&#10;        mRtcEngine?.muteLocalAudioStream(isMuted)&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setImageResource(&#10;            if (isMuted) R.drawable.ic_mic_off else R.drawable.ic_mic_on&#10;        )&#10;    }&#10;&#10;    private fun toggleSpeaker() {&#10;        isSpeakerOn = !isSpeakerOn&#10;        mRtcEngine?.setEnableSpeakerphone(isSpeakerOn)&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setImageResource(&#10;            if (isSpeakerOn) R.drawable.speaker else R.drawable.ic_speaker_off&#10;        )&#10;    }&#10;&#10;    private fun switchCamera() {&#10;        if (callType == &quot;video&quot;) {&#10;            mRtcEngine?.switchCamera()&#10;            isFrontCamera = !isFrontCamera&#10;        }&#10;    }&#10;&#10;    private fun toggleVideo() {&#10;        if (callType == &quot;video&quot;) {&#10;            isCameraOn = !isCameraOn&#10;            mRtcEngine?.muteLocalVideoStream(!isCameraOn)&#10;            localVideoContainer.visibility = if (isCameraOn) View.VISIBLE else View.GONE&#10;            findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setImageResource(&#10;                if (isCameraOn) R.drawable.ic_video_on else R.drawable.ic_video_off&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun startCallDuration() {&#10;        callStartTime = System.currentTimeMillis()&#10;        durationHandler = Handler(Looper.getMainLooper())&#10;        durationRunnable = object : Runnable {&#10;            override fun run() {&#10;                val elapsed = (System.currentTimeMillis() - callStartTime) / 1000&#10;                val minutes = elapsed / 60&#10;                val seconds = elapsed % 60&#10;                durationText.text = String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;                durationHandler?.postDelayed(this, 1000)&#10;            }&#10;        }&#10;        durationHandler?.post(durationRunnable!!)&#10;    }&#10;&#10;    private fun setupCallStatusListener() {&#10;        CallService.listenToCallStatus(callId) { status -&gt;&#10;            runOnUiThread {&#10;                when (status) {&#10;                    &quot;rejected&quot; -&gt; {&#10;                        Toast.makeText(this, &quot;Call rejected&quot;, Toast.LENGTH_SHORT).show()&#10;                        finish()&#10;                    }&#10;                    &quot;ended&quot; -&gt; {&#10;                        finish()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endCall() {&#10;        CallService.updateCallStatus(callId, &quot;ended&quot;)&#10;        CallService.endCall(callId)&#10;        leaveChannel()&#10;        finish()&#10;    }&#10;&#10;    private fun leaveChannel() {&#10;        mRtcEngine?.leaveChannel()&#10;        mRtcEngine?.stopPreview()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        durationHandler?.removeCallbacks(durationRunnable!!)&#10;        leaveChannel()&#10;        RtcEngine.destroy()&#10;        mRtcEngine = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/callScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/callScreen.kt" />
              <option name="originalContent" value="package com.hamzatariq.i210396&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.SurfaceView&#10;import android.view.View&#10;import android.widget.FrameLayout&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.hamzatariq.i210396.services.CallService&#10;import com.hamzatariq.i210396.utils.AgoraConfig&#10;import com.hamzatariq.i210396.utils.AgoraTokenGenerator&#10;import com.hamzatariq.i210396.utils.ImageUtils&#10;import io.agora.rtc2.ChannelMediaOptions&#10;import io.agora.rtc2.Constants&#10;import io.agora.rtc2.IRtcEngineEventHandler&#10;import io.agora.rtc2.RtcEngine&#10;import io.agora.rtc2.RtcEngineConfig&#10;import io.agora.rtc2.video.VideoCanvas&#10;&#10;class callScreen : AppCompatActivity() {&#10;    private var mRtcEngine: RtcEngine? = null&#10;    private lateinit var localVideoContainer: FrameLayout&#10;    private lateinit var remoteVideoContainer: FrameLayout&#10;    private lateinit var profileImage: ImageView&#10;    private lateinit var nameText: TextView&#10;    private lateinit var durationText: TextView&#10;    private lateinit var callStatusText: TextView&#10;&#10;    private var callId: String = &quot;&quot;&#10;    private var channelName: String = &quot;&quot;&#10;    private var callType: String = &quot;video&quot;&#10;    private var isIncoming: Boolean = false&#10;    private var otherUserId: String = &quot;&quot;&#10;    private var otherUserName: String = &quot;&quot;&#10;    private var otherUserImage: String = &quot;&quot;&#10;&#10;    private var isMuted = false&#10;    private var isSpeakerOn = true&#10;    private var isCameraOn = true&#10;    private var isFrontCamera = true&#10;&#10;    private var callStartTime: Long = 0&#10;    private var durationHandler: Handler? = null&#10;    private var durationRunnable: Runnable? = null&#10;&#10;    private val PERMISSION_REQ_ID = 22&#10;    private val REQUESTED_PERMISSIONS = arrayOf(&#10;        Manifest.permission.RECORD_AUDIO,&#10;        Manifest.permission.CAMERA&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_call)&#10;&#10;        // Get call data&#10;        callId = intent.getStringExtra(&quot;callId&quot;) ?: &quot;&quot;&#10;        channelName = intent.getStringExtra(&quot;channelName&quot;) ?: &quot;&quot;&#10;        callType = intent.getStringExtra(&quot;callType&quot;) ?: &quot;video&quot;&#10;        isIncoming = intent.getBooleanExtra(&quot;isIncoming&quot;, false)&#10;        otherUserId = intent.getStringExtra(&quot;otherUserId&quot;) ?: &quot;&quot;&#10;        otherUserName = intent.getStringExtra(&quot;otherUserName&quot;) ?: &quot;User&quot;&#10;        otherUserImage = intent.getStringExtra(&quot;otherUserImage&quot;) ?: &quot;&quot;&#10;&#10;        initViews()&#10;&#10;        if (checkSelfPermission()) {&#10;            initializeAndJoinChannel()&#10;        }&#10;&#10;        setupCallStatusListener()&#10;    }&#10;&#10;    private fun initViews() {&#10;        localVideoContainer = findViewById(R.id.localVideoContainer)&#10;        remoteVideoContainer = findViewById(R.id.remoteVideoContainer)&#10;        profileImage = findViewById(R.id.ivProfile)&#10;        nameText = findViewById(R.id.tvName)&#10;        durationText = findViewById(R.id.tvDuration)&#10;        callStatusText = findViewById(R.id.tvCallStatus)&#10;&#10;        nameText.text = otherUserName&#10;        if (otherUserImage.isNotEmpty()) {&#10;            ImageUtils.loadBase64Image(profileImage, otherUserImage)&#10;        }&#10;&#10;        // Initially hide video containers for audio call&#10;        if (callType == &quot;audio&quot;) {&#10;            localVideoContainer.visibility = View.GONE&#10;            remoteVideoContainer.visibility = View.GONE&#10;            profileImage.visibility = View.VISIBLE&#10;        } else {&#10;            profileImage.visibility = View.GONE&#10;        }&#10;&#10;        callStatusText.text = if (isIncoming) &quot;Connecting...&quot; else &quot;Calling...&quot;&#10;        durationText.text = &quot;00:00&quot;&#10;&#10;        // Setup buttons&#10;        findViewById&lt;ImageView&gt;(R.id.ivEndCall).setOnClickListener {&#10;            endCall()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setOnClickListener {&#10;            toggleMute()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setOnClickListener {&#10;            toggleSpeaker()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSwitchCamera)?.setOnClickListener {&#10;            switchCamera()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setOnClickListener {&#10;            toggleVideo()&#10;        }&#10;    }&#10;&#10;    private fun checkSelfPermission(): Boolean {&#10;        val permissionsNeeded = REQUESTED_PERMISSIONS.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsNeeded.isNotEmpty()) {&#10;            ActivityCompat.requestPermissions(this, permissionsNeeded.toTypedArray(), PERMISSION_REQ_ID)&#10;            return false&#10;        }&#10;        return true&#10;    }&#10;&#10;    override fun onRequestPermissionsResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray&#10;    ) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == PERMISSION_REQ_ID) {&#10;            if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {&#10;                initializeAndJoinChannel()&#10;            } else {&#10;                Toast.makeText(this, &quot;Permissions required for call&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeAndJoinChannel() {&#10;        try {&#10;            // Validate APP_ID&#10;            if (AgoraConfig.APP_ID.isEmpty() || AgoraConfig.APP_ID.contains(&quot;YOUR_AGORA&quot;)) {&#10;                Toast.makeText(this, &quot;Invalid Agora App ID. Please check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            val config = RtcEngineConfig().apply {&#10;                mContext = applicationContext&#10;                mAppId = AgoraConfig.APP_ID&#10;                mEventHandler = rtcEventHandler&#10;            }&#10;&#10;            mRtcEngine = RtcEngine.create(config)&#10;&#10;            if (mRtcEngine == null) {&#10;                Toast.makeText(this, &quot;Failed to create RTC Engine&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            if (callType == &quot;video&quot;) {&#10;                mRtcEngine?.enableVideo()&#10;                setupLocalVideo()&#10;            } else {&#10;                mRtcEngine?.disableVideo()&#10;            }&#10;&#10;            mRtcEngine?.setDefaultAudioRoutetoSpeakerphone(true)&#10;&#10;            val options = ChannelMediaOptions().apply {&#10;                channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION&#10;                clientRoleType = Constants.CLIENT_ROLE_BROADCASTER&#10;            }&#10;&#10;            // Generate Agora token for authentication&#10;            val token = if (AgoraConfig.APP_CERTIFICATE.isNotEmpty()) {&#10;                // Generate token if certificate is available&#10;                AgoraTokenGenerator.generateToken(&#10;                    channelName = channelName,&#10;                    uid = 0, // Use 0 for auto-assigned UID&#10;                    role = 1, // 1 = publisher&#10;                    privilegeExpiredTs = 0 // Will use default 1 hour expiration&#10;                )&#10;            } else {&#10;                // Use null token for testing mode (must be enabled in Agora console)&#10;                null&#10;            }&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel: $channelName&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Token mode: ${if (token != null) &quot;Authenticated&quot; else &quot;Testing (null)&quot;}&quot;)&#10;            if (token != null) {&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token generated: ${if (token.isNotEmpty()) &quot;Yes (${token.length} chars)&quot; else &quot;Failed&quot;}&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token preview: ${token.take(50)}...&quot;)&#10;            }&#10;&#10;            if (token != null &amp;&amp; token.isEmpty()) {&#10;                Toast.makeText(this, &quot;Failed to generate token. Check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            // Join channel with generated token (or null for testing mode)&#10;            val result = mRtcEngine?.joinChannel(token, channelName, 0, options)&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;joinChannel result: $result&quot;)&#10;&#10;            if (result != 0) {&#10;                Toast.makeText(this, &quot;Failed to join channel. Error code: $result&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(this, &quot;Failed to initialize call: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun setupLocalVideo() {&#10;        val surfaceView = SurfaceView(this)&#10;        localVideoContainer.addView(surfaceView)&#10;        mRtcEngine?.setupLocalVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, 0))&#10;        mRtcEngine?.startPreview()&#10;    }&#10;&#10;    private fun setupRemoteVideo(uid: Int) {&#10;        runOnUiThread {&#10;            if (callType == &quot;video&quot;) {&#10;                profileImage.visibility = View.GONE&#10;                remoteVideoContainer.visibility = View.VISIBLE&#10;&#10;                val surfaceView = SurfaceView(this)&#10;                remoteVideoContainer.addView(surfaceView)&#10;                mRtcEngine?.setupRemoteVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, uid))&#10;            }&#10;&#10;            callStatusText.visibility = View.GONE&#10;            startCallDuration()&#10;        }&#10;    }&#10;&#10;    private val rtcEventHandler = object : IRtcEngineEventHandler() {&#10;        override fun onUserJoined(uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                setupRemoteVideo(uid)&#10;            }&#10;        }&#10;&#10;        override fun onUserOffline(uid: Int, reason: Int) {&#10;            runOnUiThread {&#10;                remoteVideoContainer.removeAllViews()&#10;                endCall()&#10;            }&#10;        }&#10;&#10;        override fun onJoinChannelSuccess(channel: String?, uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                callStatusText.text = &quot;Connected&quot;&#10;            }&#10;        }&#10;&#10;        override fun onError(err: Int) {&#10;            runOnUiThread {&#10;                Toast.makeText(this@callScreen, &quot;Call error: $err&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun toggleMute() {&#10;        isMuted = !isMuted&#10;        mRtcEngine?.muteLocalAudioStream(isMuted)&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setImageResource(&#10;            if (isMuted) R.drawable.ic_mic_off else R.drawable.ic_mic_on&#10;        )&#10;    }&#10;&#10;    private fun toggleSpeaker() {&#10;        isSpeakerOn = !isSpeakerOn&#10;        mRtcEngine?.setEnableSpeakerphone(isSpeakerOn)&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setImageResource(&#10;            if (isSpeakerOn) R.drawable.speaker else R.drawable.ic_speaker_off&#10;        )&#10;    }&#10;&#10;    private fun switchCamera() {&#10;        if (callType == &quot;video&quot;) {&#10;            mRtcEngine?.switchCamera()&#10;            isFrontCamera = !isFrontCamera&#10;        }&#10;    }&#10;&#10;    private fun toggleVideo() {&#10;        if (callType == &quot;video&quot;) {&#10;            isCameraOn = !isCameraOn&#10;            mRtcEngine?.muteLocalVideoStream(!isCameraOn)&#10;            localVideoContainer.visibility = if (isCameraOn) View.VISIBLE else View.GONE&#10;            findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setImageResource(&#10;                if (isCameraOn) R.drawable.ic_video_on else R.drawable.ic_video_off&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun startCallDuration() {&#10;        callStartTime = System.currentTimeMillis()&#10;        durationHandler = Handler(Looper.getMainLooper())&#10;        durationRunnable = object : Runnable {&#10;            override fun run() {&#10;                val elapsed = (System.currentTimeMillis() - callStartTime) / 1000&#10;                val minutes = elapsed / 60&#10;                val seconds = elapsed % 60&#10;                durationText.text = String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;                durationHandler?.postDelayed(this, 1000)&#10;            }&#10;        }&#10;        durationHandler?.post(durationRunnable!!)&#10;    }&#10;&#10;    private fun setupCallStatusListener() {&#10;        CallService.listenToCallStatus(callId) { status -&gt;&#10;            runOnUiThread {&#10;                when (status) {&#10;                    &quot;rejected&quot; -&gt; {&#10;                        Toast.makeText(this, &quot;Call rejected&quot;, Toast.LENGTH_SHORT).show()&#10;                        finish()&#10;                    }&#10;                    &quot;ended&quot; -&gt; {&#10;                        finish()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endCall() {&#10;        CallService.updateCallStatus(callId, &quot;ended&quot;)&#10;        CallService.endCall(callId)&#10;        leaveChannel()&#10;        finish()&#10;    }&#10;&#10;    private fun leaveChannel() {&#10;        mRtcEngine?.leaveChannel()&#10;        mRtcEngine?.stopPreview()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        durationHandler?.removeCallbacks(durationRunnable!!)&#10;        leaveChannel()&#10;        RtcEngine.destroy()&#10;        mRtcEngine = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.i210396&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.view.SurfaceView&#10;import android.view.View&#10;import android.widget.FrameLayout&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.hamzatariq.i210396.services.CallService&#10;import com.hamzatariq.i210396.utils.AgoraConfig&#10;import com.hamzatariq.i210396.utils.AgoraTokenGenerator&#10;import com.hamzatariq.i210396.utils.ImageUtils&#10;import io.agora.rtc2.ChannelMediaOptions&#10;import io.agora.rtc2.Constants&#10;import io.agora.rtc2.IRtcEngineEventHandler&#10;import io.agora.rtc2.RtcEngine&#10;import io.agora.rtc2.RtcEngineConfig&#10;import io.agora.rtc2.video.VideoCanvas&#10;&#10;class callScreen : AppCompatActivity() {&#10;    private var mRtcEngine: RtcEngine? = null&#10;    private lateinit var localVideoContainer: FrameLayout&#10;    private lateinit var remoteVideoContainer: FrameLayout&#10;    private lateinit var profileImage: ImageView&#10;    private lateinit var nameText: TextView&#10;    private lateinit var durationText: TextView&#10;    private lateinit var callStatusText: TextView&#10;&#10;    private var callId: String = &quot;&quot;&#10;    private var channelName: String = &quot;&quot;&#10;    private var callType: String = &quot;video&quot;&#10;    private var isIncoming: Boolean = false&#10;    private var otherUserId: String = &quot;&quot;&#10;    private var otherUserName: String = &quot;&quot;&#10;    private var otherUserImage: String = &quot;&quot;&#10;&#10;    private var isMuted = false&#10;    private var isSpeakerOn = true&#10;    private var isCameraOn = true&#10;    private var isFrontCamera = true&#10;&#10;    private var callStartTime: Long = 0&#10;    private var durationHandler: Handler? = null&#10;    private var durationRunnable: Runnable? = null&#10;&#10;    private val PERMISSION_REQ_ID = 22&#10;    private val REQUESTED_PERMISSIONS = arrayOf(&#10;        Manifest.permission.RECORD_AUDIO,&#10;        Manifest.permission.CAMERA&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_call)&#10;&#10;        // Get call data&#10;        callId = intent.getStringExtra(&quot;callId&quot;) ?: &quot;&quot;&#10;        channelName = intent.getStringExtra(&quot;channelName&quot;) ?: &quot;&quot;&#10;        callType = intent.getStringExtra(&quot;callType&quot;) ?: &quot;video&quot;&#10;        isIncoming = intent.getBooleanExtra(&quot;isIncoming&quot;, false)&#10;        otherUserId = intent.getStringExtra(&quot;otherUserId&quot;) ?: &quot;&quot;&#10;        otherUserName = intent.getStringExtra(&quot;otherUserName&quot;) ?: &quot;User&quot;&#10;        otherUserImage = intent.getStringExtra(&quot;otherUserImage&quot;) ?: &quot;&quot;&#10;&#10;        initViews()&#10;&#10;        if (checkSelfPermission()) {&#10;            initializeAndJoinChannel()&#10;        }&#10;&#10;        setupCallStatusListener()&#10;    }&#10;&#10;    private fun initViews() {&#10;        localVideoContainer = findViewById(R.id.localVideoContainer)&#10;        remoteVideoContainer = findViewById(R.id.remoteVideoContainer)&#10;        profileImage = findViewById(R.id.ivProfile)&#10;        nameText = findViewById(R.id.tvName)&#10;        durationText = findViewById(R.id.tvDuration)&#10;        callStatusText = findViewById(R.id.tvCallStatus)&#10;&#10;        nameText.text = otherUserName&#10;        if (otherUserImage.isNotEmpty()) {&#10;            ImageUtils.loadBase64Image(profileImage, otherUserImage)&#10;        }&#10;&#10;        // Initially hide video containers for audio call&#10;        if (callType == &quot;audio&quot;) {&#10;            localVideoContainer.visibility = View.GONE&#10;            remoteVideoContainer.visibility = View.GONE&#10;            profileImage.visibility = View.VISIBLE&#10;        } else {&#10;            profileImage.visibility = View.GONE&#10;        }&#10;&#10;        callStatusText.text = if (isIncoming) &quot;Connecting...&quot; else &quot;Calling...&quot;&#10;        durationText.text = &quot;00:00&quot;&#10;&#10;        // Setup buttons&#10;        findViewById&lt;ImageView&gt;(R.id.ivEndCall).setOnClickListener {&#10;            endCall()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setOnClickListener {&#10;            toggleMute()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setOnClickListener {&#10;            toggleSpeaker()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivSwitchCamera)?.setOnClickListener {&#10;            switchCamera()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setOnClickListener {&#10;            toggleVideo()&#10;        }&#10;    }&#10;&#10;    private fun checkSelfPermission(): Boolean {&#10;        val permissionsNeeded = REQUESTED_PERMISSIONS.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsNeeded.isNotEmpty()) {&#10;            ActivityCompat.requestPermissions(this, permissionsNeeded.toTypedArray(), PERMISSION_REQ_ID)&#10;            return false&#10;        }&#10;        return true&#10;    }&#10;&#10;    override fun onRequestPermissionsResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray&#10;    ) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        if (requestCode == PERMISSION_REQ_ID) {&#10;            if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {&#10;                initializeAndJoinChannel()&#10;            } else {&#10;                Toast.makeText(this, &quot;Permissions required for call&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeAndJoinChannel() {&#10;        try {&#10;            // Validate APP_ID&#10;            if (AgoraConfig.APP_ID.isEmpty() || AgoraConfig.APP_ID.contains(&quot;YOUR_AGORA&quot;)) {&#10;                Toast.makeText(this, &quot;Invalid Agora App ID. Please check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            val config = RtcEngineConfig().apply {&#10;                mContext = applicationContext&#10;                mAppId = AgoraConfig.APP_ID&#10;                mEventHandler = rtcEventHandler&#10;            }&#10;&#10;            mRtcEngine = RtcEngine.create(config)&#10;&#10;            if (mRtcEngine == null) {&#10;                Toast.makeText(this, &quot;Failed to create RTC Engine&quot;, Toast.LENGTH_SHORT).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            if (callType == &quot;video&quot;) {&#10;                mRtcEngine?.enableVideo()&#10;                setupLocalVideo()&#10;            } else {&#10;                mRtcEngine?.disableVideo()&#10;            }&#10;&#10;            mRtcEngine?.setDefaultAudioRoutetoSpeakerphone(true)&#10;&#10;            val options = ChannelMediaOptions().apply {&#10;                channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION&#10;                clientRoleType = Constants.CLIENT_ROLE_BROADCASTER&#10;            }&#10;&#10;            // Generate Agora token for authentication&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;=== TOKEN GENERATION DEBUG ===&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;APP_ID: ${AgoraConfig.APP_ID}&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;APP_CERTIFICATE: ${AgoraConfig.APP_CERTIFICATE}&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel Name: $channelName&quot;)&#10;&#10;            val token = if (AgoraConfig.APP_CERTIFICATE.isNotEmpty()) {&#10;                // Generate token if certificate is available&#10;                val generatedToken = AgoraTokenGenerator.generateToken(&#10;                    channelName = channelName,&#10;                    uid = 0, // Use 0 for auto-assigned UID&#10;                    role = 1, // 1 = publisher&#10;                    privilegeExpiredTs = 0 // Will use default 1 hour expiration&#10;                )&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token generated: $generatedToken&quot;)&#10;                generatedToken&#10;            } else {&#10;                // Use null token for testing mode (must be enabled in Agora console)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Using null token (testing mode)&quot;)&#10;                null&#10;            }&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Channel: $channelName&quot;)&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;Token mode: ${if (token != null) &quot;Authenticated&quot; else &quot;Testing (null)&quot;}&quot;)&#10;            if (token != null) {&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token generated: ${if (token.isNotEmpty()) &quot;Yes (${token.length} chars)&quot; else &quot;Failed&quot;}&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token preview: ${token.take(50)}...&quot;)&#10;                android.util.Log.d(&quot;CallScreen&quot;, &quot;Token full: $token&quot;)&#10;            }&#10;&#10;            if (token != null &amp;&amp; token.isEmpty()) {&#10;                Toast.makeText(this, &quot;Failed to generate token. Check AgoraConfig.&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;                return&#10;            }&#10;&#10;            // Join channel with generated token (or null for testing mode)&#10;            val result = mRtcEngine?.joinChannel(token, channelName, 0, options)&#10;&#10;            android.util.Log.d(&quot;CallScreen&quot;, &quot;joinChannel result: $result&quot;)&#10;&#10;            if (result != 0) {&#10;                Toast.makeText(this, &quot;Failed to join channel. Error code: $result&quot;, Toast.LENGTH_LONG).show()&#10;                finish()&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            Toast.makeText(this, &quot;Failed to initialize call: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun setupLocalVideo() {&#10;        val surfaceView = SurfaceView(this)&#10;        localVideoContainer.addView(surfaceView)&#10;        mRtcEngine?.setupLocalVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, 0))&#10;        mRtcEngine?.startPreview()&#10;    }&#10;&#10;    private fun setupRemoteVideo(uid: Int) {&#10;        runOnUiThread {&#10;            if (callType == &quot;video&quot;) {&#10;                profileImage.visibility = View.GONE&#10;                remoteVideoContainer.visibility = View.VISIBLE&#10;&#10;                val surfaceView = SurfaceView(this)&#10;                remoteVideoContainer.addView(surfaceView)&#10;                mRtcEngine?.setupRemoteVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_HIDDEN, uid))&#10;            }&#10;&#10;            callStatusText.visibility = View.GONE&#10;            startCallDuration()&#10;        }&#10;    }&#10;&#10;    private val rtcEventHandler = object : IRtcEngineEventHandler() {&#10;        override fun onUserJoined(uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                setupRemoteVideo(uid)&#10;            }&#10;        }&#10;&#10;        override fun onUserOffline(uid: Int, reason: Int) {&#10;            runOnUiThread {&#10;                remoteVideoContainer.removeAllViews()&#10;                endCall()&#10;            }&#10;        }&#10;&#10;        override fun onJoinChannelSuccess(channel: String?, uid: Int, elapsed: Int) {&#10;            runOnUiThread {&#10;                callStatusText.text = &quot;Connected&quot;&#10;            }&#10;        }&#10;&#10;        override fun onError(err: Int) {&#10;            runOnUiThread {&#10;                Toast.makeText(this@callScreen, &quot;Call error: $err&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun toggleMute() {&#10;        isMuted = !isMuted&#10;        mRtcEngine?.muteLocalAudioStream(isMuted)&#10;        findViewById&lt;ImageView&gt;(R.id.ivMute)?.setImageResource(&#10;            if (isMuted) R.drawable.ic_mic_off else R.drawable.ic_mic_on&#10;        )&#10;    }&#10;&#10;    private fun toggleSpeaker() {&#10;        isSpeakerOn = !isSpeakerOn&#10;        mRtcEngine?.setEnableSpeakerphone(isSpeakerOn)&#10;        findViewById&lt;ImageView&gt;(R.id.ivSpeaker).setImageResource(&#10;            if (isSpeakerOn) R.drawable.speaker else R.drawable.ic_speaker_off&#10;        )&#10;    }&#10;&#10;    private fun switchCamera() {&#10;        if (callType == &quot;video&quot;) {&#10;            mRtcEngine?.switchCamera()&#10;            isFrontCamera = !isFrontCamera&#10;        }&#10;    }&#10;&#10;    private fun toggleVideo() {&#10;        if (callType == &quot;video&quot;) {&#10;            isCameraOn = !isCameraOn&#10;            mRtcEngine?.muteLocalVideoStream(!isCameraOn)&#10;            localVideoContainer.visibility = if (isCameraOn) View.VISIBLE else View.GONE&#10;            findViewById&lt;ImageView&gt;(R.id.ivToggleVideo)?.setImageResource(&#10;                if (isCameraOn) R.drawable.ic_video_on else R.drawable.ic_video_off&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun startCallDuration() {&#10;        callStartTime = System.currentTimeMillis()&#10;        durationHandler = Handler(Looper.getMainLooper())&#10;        durationRunnable = object : Runnable {&#10;            override fun run() {&#10;                val elapsed = (System.currentTimeMillis() - callStartTime) / 1000&#10;                val minutes = elapsed / 60&#10;                val seconds = elapsed % 60&#10;                durationText.text = String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;                durationHandler?.postDelayed(this, 1000)&#10;            }&#10;        }&#10;        durationHandler?.post(durationRunnable!!)&#10;    }&#10;&#10;    private fun setupCallStatusListener() {&#10;        CallService.listenToCallStatus(callId) { status -&gt;&#10;            runOnUiThread {&#10;                when (status) {&#10;                    &quot;rejected&quot; -&gt; {&#10;                        Toast.makeText(this, &quot;Call rejected&quot;, Toast.LENGTH_SHORT).show()&#10;                        finish()&#10;                    }&#10;                    &quot;ended&quot; -&gt; {&#10;                        finish()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun endCall() {&#10;        CallService.updateCallStatus(callId, &quot;ended&quot;)&#10;        CallService.endCall(callId)&#10;        leaveChannel()&#10;        finish()&#10;    }&#10;&#10;    private fun leaveChannel() {&#10;        mRtcEngine?.leaveChannel()&#10;        mRtcEngine?.stopPreview()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        durationHandler?.removeCallbacks(durationRunnable!!)&#10;        leaveChannel()&#10;        RtcEngine.destroy()&#10;        mRtcEngine = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/utils/AgoraConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/utils/AgoraConfig.kt" />
              <option name="originalContent" value="package com.hamzatariq.i210396.utils&#10;&#10;object AgoraConfig {&#10;    // Agora App ID - Successfully configured!&#10;    const val APP_ID = &quot;fc45bacc392b45c58b8c0b3fc4e8b5e3&quot;&#10;&#10;    // Agora App Certificate (Primary Certificate)&#10;    // UNCOMMENT the line below when you enable token authentication in Agora Console&#10;    // For testing without token, keep this empty&#10;    const val APP_CERTIFICATE = &quot;&quot; // Set to &quot;0708667746bd4b8eb95ad1105e4b56fe&quot; for production&#10;&#10;    // Callback Secret&#10;    const val CALLBACK_SECRET = &quot;09999ad42b32a41002db5a46c39d025b&quot;&#10;&#10;    // Server URL&#10;    const val SERVER_URL = &quot;wss://webliveroom460418059-api.coolzcloud.com/ws&quot;&#10;&#10;    // Channel name will be generated dynamically for each call&#10;    fun generateChannelName(userId1: String, userId2: String): String {&#10;        return if (userId1 &lt; userId2) {&#10;            &quot;call_${userId1}_${userId2}&quot;&#10;        } else {&#10;            &quot;call_${userId2}_${userId1}&quot;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.i210396.utils&#10;&#10;object AgoraConfig {&#10;    // Agora App ID - Successfully configured!&#10;    const val APP_ID = &quot;fc45bacc392b45c58b8c0b3fc4e8b5e3&quot;&#10;&#10;    // Agora App Certificate (Primary Certificate)&#10;    // Enabled for token authentication&#10;    const val APP_CERTIFICATE = &quot;0708667746bd4b8eb95ad1105e4b56fe&quot;&#10;&#10;    // Callback Secret&#10;    const val CALLBACK_SECRET = &quot;09999ad42b32a41002db5a46c39d025b&quot;&#10;&#10;    // Server URL&#10;    const val SERVER_URL = &quot;wss://webliveroom460418059-api.coolzcloud.com/ws&quot;&#10;&#10;    // Channel name will be generated dynamically for each call&#10;    fun generateChannelName(userId1: String, userId2: String): String {&#10;        return if (userId1 &lt; userId2) {&#10;            &quot;call_${userId1}_${userId2}&quot;&#10;        } else {&#10;            &quot;call_${userId2}_${userId1}&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/utils/AgoraTokenGenerator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/hamzatariq/i210396/utils/AgoraTokenGenerator.kt" />
              <option name="originalContent" value="package com.hamzatariq.i210396.utils&#10;&#10;import android.util.Base64&#10;import android.util.Log&#10;import java.nio.ByteBuffer&#10;import java.nio.ByteOrder&#10;import javax.crypto.Mac&#10;import javax.crypto.spec.SecretKeySpec&#10;import java.util.TreeMap&#10;import java.util.zip.CRC32&#10;&#10;object AgoraTokenGenerator {&#10;&#10;    private const val TAG = &quot;AgoraTokenGenerator&quot;&#10;&#10;    /**&#10;     * Generate Agora RTC token&#10;     * This is a simplified version - in production, use a backend server&#10;     */&#10;    fun generateToken(&#10;        channelName: String,&#10;        uid: Int,&#10;        role: Int = 1,&#10;        privilegeExpiredTs: Int = 0&#10;    ): String {&#10;        return try {&#10;            val appId = AgoraConfig.APP_ID&#10;            val appCertificate = AgoraConfig.APP_CERTIFICATE&#10;&#10;            if (appId.isEmpty() || appCertificate.isEmpty()) {&#10;                Log.e(TAG, &quot;App ID or Certificate is empty&quot;)&#10;                return &quot;&quot;&#10;            }&#10;&#10;            val privilegeExpired = if (privilegeExpiredTs == 0) {&#10;                (System.currentTimeMillis() / 1000 + 3600).toInt() // 1 hour&#10;            } else {&#10;                privilegeExpiredTs&#10;            }&#10;&#10;            Log.d(TAG, &quot;Generating token for channel: $channelName, uid: $uid&quot;)&#10;&#10;            val token = buildTokenWithUid(appId, appCertificate, channelName, uid, privilegeExpired)&#10;&#10;            Log.d(TAG, &quot;Token generated successfully, length: ${token.length}&quot;)&#10;            token&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to generate token: ${e.message}&quot;, e)&#10;            &quot;&quot;&#10;        }&#10;    }&#10;&#10;    fun getExpirationTimestamp(expirationTimeInSeconds: Int = 3600): Int {&#10;        return (System.currentTimeMillis() / 1000 + expirationTimeInSeconds).toInt()&#10;    }&#10;&#10;    private fun buildTokenWithUid(&#10;        appId: String,&#10;        appCertificate: String,&#10;        channelName: String,&#10;        uid: Int,&#10;        privilegeExpired: Int&#10;    ): String {&#10;        return AccessToken(appId, appCertificate, channelName, uid.toString()).apply {&#10;            addPrivilege(AccessToken.Privileges.kJoinChannel, privilegeExpired)&#10;            addPrivilege(AccessToken.Privileges.kPublishAudioStream, privilegeExpired)&#10;            addPrivilege(AccessToken.Privileges.kPublishVideoStream, privilegeExpired)&#10;            addPrivilege(AccessToken.Privileges.kPublishDataStream, privilegeExpired)&#10;        }.build()&#10;    }&#10;&#10;    // AccessToken implementation based on Agora's official algorithm&#10;    private class AccessToken(&#10;        private val appId: String,&#10;        private val appCertificate: String,&#10;        private val channelName: String,&#10;        private val uid: String&#10;    ) {&#10;        private val salt = (Math.random() * 99999999).toInt()&#10;        private val ts = (System.currentTimeMillis() / 1000).toInt()&#10;        private val messages = TreeMap&lt;Short, Int&gt;()&#10;&#10;        object Privileges {&#10;            const val kJoinChannel: Short = 1&#10;            const val kPublishAudioStream: Short = 2&#10;            const val kPublishVideoStream: Short = 3&#10;            const val kPublishDataStream: Short = 4&#10;        }&#10;&#10;        fun addPrivilege(privilege: Short, expireTimestamp: Int) {&#10;            messages[privilege] = expireTimestamp&#10;        }&#10;&#10;        fun build(): String {&#10;            val msg = pack()&#10;            val signature = hmacSign(appCertificate, msg)&#10;            val crcChannelName = crc32(channelName.toByteArray())&#10;            val crcUid = crc32(uid.toByteArray())&#10;&#10;            val content = packContent(signature, crcChannelName, crcUid, msg)&#10;            return &quot;007&quot; + Base64.encodeToString(content, Base64.NO_WRAP)&#10;        }&#10;&#10;        private fun pack(): ByteArray {&#10;            val buffer = ByteBuffer.allocate(1024)&#10;            buffer.order(ByteOrder.LITTLE_ENDIAN)&#10;&#10;            buffer.putInt(salt)&#10;            buffer.putInt(ts)&#10;            buffer.putInt(messages.size)&#10;&#10;            messages.forEach { (key, value) -&gt;&#10;                buffer.putShort(key)&#10;                buffer.putInt(value)&#10;            }&#10;&#10;            val messageBytes = ByteArray(buffer.position())&#10;            buffer.flip()&#10;            buffer.get(messageBytes)&#10;&#10;            return messageBytes&#10;        }&#10;&#10;        private fun packContent(&#10;            signature: ByteArray,&#10;            crcChannelName: Int,&#10;            crcUid: Int,&#10;            message: ByteArray&#10;        ): ByteArray {&#10;            val buffer = ByteBuffer.allocate(1024)&#10;            buffer.order(ByteOrder.LITTLE_ENDIAN)&#10;&#10;            // Pack signature&#10;            buffer.putShort(signature.size.toShort())&#10;            buffer.put(signature)&#10;&#10;            // Pack crc channel name&#10;            buffer.putInt(crcChannelName)&#10;&#10;            // Pack crc uid&#10;            buffer.putInt(crcUid)&#10;&#10;            // Pack message&#10;            buffer.putShort(message.size.toShort())&#10;            buffer.put(message)&#10;&#10;            val content = ByteArray(buffer.position())&#10;            buffer.flip()&#10;            buffer.get(content)&#10;&#10;            return content&#10;        }&#10;&#10;        private fun hmacSign(key: String, message: ByteArray): ByteArray {&#10;            val keySpec = SecretKeySpec(key.toByteArray(Charsets.UTF_8), &quot;HmacSHA256&quot;)&#10;            val mac = Mac.getInstance(&quot;HmacSHA256&quot;)&#10;            mac.init(keySpec)&#10;            return mac.doFinal(message)&#10;        }&#10;&#10;        private fun crc32(data: ByteArray): Int {&#10;            val crc = CRC32()&#10;            crc.update(data)&#10;            return crc.value.toInt()&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.hamzatariq.i210396.utils&#10;&#10;import android.util.Base64&#10;import android.util.Log&#10;import java.nio.ByteBuffer&#10;import java.nio.ByteOrder&#10;import javax.crypto.Mac&#10;import javax.crypto.spec.SecretKeySpec&#10;import java.util.TreeMap&#10;import java.util.zip.CRC32&#10;&#10;object AgoraTokenGenerator {&#10;&#10;    private const val TAG = &quot;AgoraTokenGenerator&quot;&#10;    private const val VERSION = &quot;007&quot;&#10;&#10;    /**&#10;     * Generate Agora RTC token&#10;     * Based on Agora's official token generation algorithm&#10;     */&#10;    fun generateToken(&#10;        channelName: String,&#10;        uid: Int,&#10;        role: Int = 1,&#10;        privilegeExpiredTs: Int = 0&#10;    ): String {&#10;        return try {&#10;            val appId = AgoraConfig.APP_ID&#10;            val appCertificate = AgoraConfig.APP_CERTIFICATE&#10;&#10;            if (appId.isEmpty() || appCertificate.isEmpty()) {&#10;                Log.e(TAG, &quot;App ID or Certificate is empty&quot;)&#10;                Log.e(TAG, &quot;APP_ID: $appId&quot;)&#10;                Log.e(TAG, &quot;APP_CERTIFICATE length: ${appCertificate.length}&quot;)&#10;                return &quot;&quot;&#10;            }&#10;&#10;            // Calculate token expiration time (default 24 hours from now)&#10;            val tokenExpirationTs = if (privilegeExpiredTs == 0) {&#10;                (System.currentTimeMillis() / 1000 + 86400).toInt() // 24 hours&#10;            } else {&#10;                privilegeExpiredTs&#10;            }&#10;&#10;            Log.d(TAG, &quot;=== Token Generation Details ===&quot;)&#10;            Log.d(TAG, &quot;Channel: $channelName&quot;)&#10;            Log.d(TAG, &quot;UID: $uid&quot;)&#10;            Log.d(TAG, &quot;Token Expiration: $tokenExpirationTs&quot;)&#10;            Log.d(TAG, &quot;Current Time: ${System.currentTimeMillis() / 1000}&quot;)&#10;&#10;            val token = buildToken(appId, appCertificate, channelName, uid, tokenExpirationTs)&#10;&#10;            Log.d(TAG, &quot;Token generated successfully&quot;)&#10;            Log.d(TAG, &quot;Token length: ${token.length}&quot;)&#10;            Log.d(TAG, &quot;Token: $token&quot;)&#10;            &#10;            token&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to generate token: ${e.message}&quot;, e)&#10;            e.printStackTrace()&#10;            &quot;&quot;&#10;        }&#10;    }&#10;&#10;    private fun buildToken(&#10;        appId: String,&#10;        appCertificate: String,&#10;        channelName: String,&#10;        uid: Int,&#10;        privilegeExpiredTs: Int&#10;    ): String {&#10;        val uidStr = uid.toString()&#10;        val salt = (Math.random() * 99999999).toInt()&#10;        val ts = (System.currentTimeMillis() / 1000).toInt()&#10;&#10;        // Build privileges map&#10;        val messages = TreeMap&lt;Short, Int&gt;()&#10;        messages[1] = privilegeExpiredTs // kJoinChannel&#10;        messages[2] = privilegeExpiredTs // kPublishAudioStream&#10;        messages[3] = privilegeExpiredTs // kPublishVideoStream&#10;        messages[4] = privilegeExpiredTs // kPublishDataStream&#10;&#10;        // Pack message&#10;        val messageBuffer = ByteBuffer.allocate(1024).order(ByteOrder.LITTLE_ENDIAN)&#10;        messageBuffer.putInt(salt)&#10;        messageBuffer.putInt(ts)&#10;        messageBuffer.putInt(messages.size)&#10;&#10;        for ((privilege, expireTime) in messages) {&#10;            messageBuffer.putShort(privilege)&#10;            messageBuffer.putInt(expireTime)&#10;        }&#10;&#10;        val messageBytes = ByteArray(messageBuffer.position())&#10;        messageBuffer.flip()&#10;        messageBuffer.get(messageBytes)&#10;&#10;        // Generate signature&#10;        val signature = hmacSha256(appCertificate.toByteArray(Charsets.UTF_8), messageBytes)&#10;&#10;        // Calculate CRC32&#10;        val crcChannelName = crc32(channelName.toByteArray())&#10;        val crcUid = crc32(uidStr.toByteArray())&#10;&#10;        // Pack content&#10;        val contentBuffer = ByteBuffer.allocate(2048).order(ByteOrder.LITTLE_ENDIAN)&#10;        &#10;        // Signature&#10;        contentBuffer.putShort(signature.size.toShort())&#10;        contentBuffer.put(signature)&#10;        &#10;        // CRC channel name&#10;        contentBuffer.putInt(crcChannelName)&#10;        &#10;        // CRC UID&#10;        contentBuffer.putInt(crcUid)&#10;        &#10;        // Message&#10;        contentBuffer.putShort(messageBytes.size.toShort())&#10;        contentBuffer.put(messageBytes)&#10;&#10;        val contentBytes = ByteArray(contentBuffer.position())&#10;        contentBuffer.flip()&#10;        contentBuffer.get(contentBytes)&#10;&#10;        // Encode and build final token&#10;        val base64Content = Base64.encodeToString(contentBytes, Base64.NO_WRAP)&#10;        return VERSION + appId + base64Content&#10;    }&#10;&#10;    private fun hmacSha256(key: ByteArray, data: ByteArray): ByteArray {&#10;        val mac = Mac.getInstance(&quot;HmacSHA256&quot;)&#10;        val secretKeySpec = SecretKeySpec(key, &quot;HmacSHA256&quot;)&#10;        mac.init(secretKeySpec)&#10;        return mac.doFinal(data)&#10;    }&#10;&#10;    private fun crc32(data: ByteArray): Int {&#10;        val crc = CRC32()&#10;        crc.update(data)&#10;        return crc.value.toInt()&#10;    }&#10;&#10;    fun getExpirationTimestamp(expirationTimeInSeconds: Int = 3600): Int {&#10;        return (System.currentTimeMillis() / 1000 + expirationTimeInSeconds).toInt()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build_project.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build_project.bat" />
              <option name="updatedContent" value="@echo off&#10;cd /d &quot;E:\Mobile dev Projects\i210396&quot;&#10;echo Building Android project...&#10;call gradlew.bat clean build&#10;pause&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/rebuild.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/rebuild.bat" />
              <option name="updatedContent" value="@echo off&#10;cd /d &quot;E:\Mobile dev Projects\i210396&quot;&#10;echo Cleaning build cache...&#10;call gradlew.bat clean&#10;echo.&#10;echo Building project...&#10;call gradlew.bat build&#10;echo.&#10;echo Build complete!&#10;pause&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/settings.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/settings.gradle.kts" />
              <option name="originalContent" value="pluginManagement {&#10;    repositories {&#10;        google {&#10;            content {&#10;                includeGroupByRegex(&quot;com\\.android.*&quot;)&#10;                includeGroupByRegex(&quot;com\\.google.*&quot;)&#10;                includeGroupByRegex(&quot;androidx.*&quot;)&#10;            }&#10;        }&#10;        mavenCentral()&#10;        gradlePluginPortal()&#10;    }&#10;}&#10;dependencyResolutionManagement {&#10;    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)&#10;    repositories {&#10;        google()&#10;        mavenCentral()&#10;    }&#10;}&#10;&#10;rootProject.name = &quot;i210396_i211384&quot;&#10;include(&quot;:app&quot;)&#10;" />
              <option name="updatedContent" value="pluginManagement {&#10;    repositories {&#10;        google {&#10;            content {&#10;                includeGroupByRegex(&quot;com\\.android.*&quot;)&#10;                includeGroupByRegex(&quot;com\\.google.*&quot;)&#10;                includeGroupByRegex(&quot;androidx.*&quot;)&#10;            }&#10;        }&#10;        mavenCentral()&#10;        gradlePluginPortal()&#10;    }&#10;}&#10;dependencyResolutionManagement {&#10;    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)&#10;    repositories {&#10;        google()&#10;        mavenCentral()&#10;        // CRITICAL: Add Agora Maven repository for SDK access&#10;        maven {&#10;            url = uri(&quot;https://download.agora.io/android/release&quot;)&#10;        }&#10;        maven {&#10;            url = uri(&quot;https://jitpack.io&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;rootProject.name = &quot;i210396_i211384&quot;&#10;include(&quot;:app&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>